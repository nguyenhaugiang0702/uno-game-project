"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/game/page",{

/***/ "(app-pages-browser)/./stores/features/gameSlice.ts":
/*!**************************************!*\
  !*** ./stores/features/gameSlice.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gameSlice: function() { return /* binding */ gameSlice; },\n/* harmony export */   init: function() { return /* binding */ init; },\n/* harmony export */   moveCard: function() { return /* binding */ moveCard; },\n/* harmony export */   movePlayer: function() { return /* binding */ movePlayer; },\n/* harmony export */   ready: function() { return /* binding */ ready; },\n/* harmony export */   setInLobby: function() { return /* binding */ setInLobby; },\n/* harmony export */   setPlayerId: function() { return /* binding */ setPlayerId; },\n/* harmony export */   stopGame: function() { return /* binding */ stopGame; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _bots_server_BotsServer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/bots-server/BotsServer */ \"(app-pages-browser)/./bots-server/BotsServer.ts\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/helpers */ \"(app-pages-browser)/./utils/helpers.ts\");\n\n\n\nlet cardLayoutIdIdx = 111;\nfunction generateDrawingCards(cnt) {\n    return Array(cnt).fill(0).map(()=>({\n            layoutId: \"id_\".concat(cardLayoutIdIdx++)\n        }));\n}\nconst initialState = {\n    playerId: \"\",\n    currentPlayer: 0,\n    nextPlayre: 0,\n    orderOffset: 0,\n    direction: 1,\n    tableStack: [],\n    drawingStack: [],\n    players: [],\n    lastPlayerDrawed: false,\n    inGame: false,\n    inLobby: false,\n    pendingFirstCard: undefined\n};\nconst gameSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__.createSlice)({\n    name: \"game\",\n    initialState,\n    reducers: {\n        setPlayerId (state, action) {\n            state.playerId = action.payload;\n        },\n        init: (state, action)=>{\n            const { players, cards: startingCards, firstCard } = action.payload;\n            state.direction = 1;\n            state.tableStack = [];\n            state.pendingFirstCard = firstCard ? {\n                ...firstCard,\n                layoutId: \"table_\".concat(cardLayoutIdIdx++),\n                rotationY: 0\n            } : undefined;\n            state.lastPlayerDrawed = false;\n            state.inGame = true;\n            state.inLobby = false;\n            let playersFinal = [];\n            let myIdx = 0;\n            while(myIdx < players.length){\n                if (players[myIdx].id === state.playerId) break;\n                myIdx++;\n            }\n            for(let i = myIdx; i < players.length; i++){\n                playersFinal.push(players[i]);\n            }\n            state.currentPlayer = playersFinal.length % players.length;\n            for(let i = 0; i < myIdx; i++){\n                playersFinal.push(players[i]);\n            }\n            let cardsToDistribute = startingCards.map((c)=>({\n                    ...c,\n                    layoutId: \"id_\".concat(cardLayoutIdIdx++),\n                    rotationY: 0,\n                    playable: myIdx === 0,\n                    forPlayer: 0\n                }));\n            for(let i = 1; i < playersFinal.length; i++){\n                cardsToDistribute = cardsToDistribute.concat(Array(startingCards.length).fill(0).map(()=>({\n                        layoutId: \"id_\".concat(cardLayoutIdIdx++),\n                        forPlayer: i\n                    })));\n            }\n            state.players = playersFinal;\n            state.drawingStack = cardsToDistribute.concat(generateDrawingCards(20));\n            state.orderOffset = myIdx;\n        },\n        ready (state) {\n            state.players = state.players.map((player, idx)=>{\n                return {\n                    ...player,\n                    cards: state.drawingStack.filter((c)=>c.forPlayer === idx)\n                };\n            });\n            state.drawingStack = state.drawingStack.filter((c)=>typeof c.forPlayer === \"undefined\");\n            if (!state.tableStack.length && state.pendingFirstCard) {\n                state.tableStack = [\n                    state.pendingFirstCard\n                ];\n                state.pendingFirstCard = undefined;\n            }\n        },\n        stopGame (state) {\n            state.inGame = false;\n        },\n        setInLobby (state, action) {\n            state.inLobby = action.payload;\n        },\n        moveCard (state, action) {\n            let { curPlayer, nextPlayer, card, cardsToDraw = [], draw } = action.payload;\n            // Convert curPlayer from server index to UI index\n            curPlayer = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.wrapMod)(curPlayer - state.orderOffset, state.players.length);\n            const curPlayerObj = state.players[curPlayer];\n            nextPlayer = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.wrapMod)(nextPlayer - state.orderOffset, state.players.length);\n            if ((card === null || card === void 0 ? void 0 : card.action) === \"reverse\") state.direction *= -1;\n            if (draw) {\n                state.players = state.players.map((p)=>{\n                    if (p.id === curPlayerObj.id) {\n                        let newCards = state.drawingStack.slice(0, draw);\n                        if (curPlayerObj.id === state.playerId && cardsToDraw) {\n                            newCards = newCards.map((c, idx)=>({\n                                    ...c,\n                                    ...cardsToDraw[idx],\n                                    rotationY: 0\n                                }));\n                        }\n                        return {\n                            ...p,\n                            cards: p.cards.concat(newCards)\n                        };\n                    }\n                    return p;\n                });\n                state.drawingStack = state.drawingStack.slice(draw).concat(generateDrawingCards(draw));\n                state.lastPlayerDrawed = true;\n            }\n            if (card) {\n                let layoutId = \"\";\n                let shouldFlip = false;\n                // Check if player actually has the card (or any card if not local player)\n                const hasCard = curPlayerObj.cards.some((c)=>curPlayerObj.id === state.playerId ? c.id === (card === null || card === void 0 ? void 0 : card.id) : true);\n                if (hasCard && curPlayerObj.cards.length > 0) {\n                    if (curPlayerObj.id !== state.playerId) {\n                        layoutId = curPlayerObj.cards[Math.floor(Math.random() * curPlayerObj.cards.length)].layoutId;\n                        shouldFlip = true;\n                    } else {\n                        var _curPlayerObj_cards_find;\n                        layoutId = (_curPlayerObj_cards_find = curPlayerObj.cards.find((c)=>c.id === (card === null || card === void 0 ? void 0 : card.id))) === null || _curPlayerObj_cards_find === void 0 ? void 0 : _curPlayerObj_cards_find.layoutId;\n                        const cardToMove = curPlayerObj.cards.filter((c)=>c.layoutId === layoutId)[0];\n                        if (cardToMove) {\n                            card.color = cardToMove.color;\n                            card.action = cardToMove.action;\n                            card.digit = cardToMove.digit;\n                        }\n                    }\n                } else {\n                    // Card not in hand (e.g. first card played by system)\n                    // Animate from drawing stack (deck)\n                    layoutId = \"system_move_\".concat(cardLayoutIdIdx++);\n                    shouldFlip = true;\n                }\n                state.tableStack = [\n                    ...state.tableStack.slice(-1),\n                    {\n                        layoutId: layoutId || \"unknown_\".concat(cardLayoutIdIdx++),\n                        color: card.color,\n                        action: card.action,\n                        digit: card.digit,\n                        flip: shouldFlip,\n                        rotationY: 0\n                    }\n                ];\n                // Only remove card if it was in hand\n                if (hasCard) {\n                    state.players = state.players.map((p)=>{\n                        if (p === curPlayerObj) {\n                            return {\n                                ...p,\n                                cards: p.cards.filter((c)=>c.layoutId !== layoutId)\n                            };\n                        }\n                        return p;\n                    });\n                }\n                state.lastPlayerDrawed = false;\n            }\n            state.nextPlayre = nextPlayer;\n        },\n        movePlayer (state) {\n            state.players = state.players.map((p)=>{\n                if (p.id === state.playerId) {\n                    const myTurn = state.nextPlayre === 0;\n                    return {\n                        ...p,\n                        cards: p.cards.map((c)=>{\n                            return {\n                                ...c,\n                                playable: myTurn && (0,_bots_server_BotsServer__WEBPACK_IMPORTED_MODULE_0__.canPlayCard)(state.tableStack[state.tableStack.length - 1], c, state.lastPlayerDrawed)\n                            };\n                        })\n                    };\n                }\n                return p;\n            });\n            state.currentPlayer = state.nextPlayre;\n        }\n    }\n});\nconst { init, ready, stopGame, moveCard, movePlayer, setInLobby, setPlayerId } = gameSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (gameSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3Jlcy9mZWF0dXJlcy9nYW1lU2xpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDUDtBQUNiO0FBa0J6QyxJQUFJRyxrQkFBa0I7QUFFdEIsU0FBU0MscUJBQXFCQyxHQUFXO0lBQ3ZDLE9BQU9DLE1BQU1ELEtBQ1ZFLElBQUksQ0FBQyxHQUNMQyxHQUFHLENBQUMsSUFBTztZQUFFQyxVQUFVLE1BQXdCLE9BQWxCTjtRQUFvQjtBQUN0RDtBQUVBLE1BQU1PLGVBQTJCO0lBQy9CQyxVQUFVO0lBQ1ZDLGVBQWU7SUFDZkMsWUFBWTtJQUNaQyxhQUFhO0lBQ2JDLFdBQVc7SUFDWEMsWUFBWSxFQUFFO0lBQ2RDLGNBQWMsRUFBRTtJQUNoQkMsU0FBUyxFQUFFO0lBQ1hDLGtCQUFrQjtJQUNsQkMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLGtCQUFrQkM7QUFDcEI7QUFFTyxNQUFNQyxZQUFZeEIsNkRBQVdBLENBQUM7SUFDbkN5QixNQUFNO0lBQ05mO0lBQ0FnQixVQUFVO1FBQ1JDLGFBQVlDLEtBQUssRUFBRUMsTUFBNkI7WUFDOUNELE1BQU1qQixRQUFRLEdBQUdrQixPQUFPQyxPQUFPO1FBQ2pDO1FBQ0FDLE1BQU0sQ0FDSkgsT0FDQUM7WUFFQSxNQUFNLEVBQUVYLE9BQU8sRUFBRWMsT0FBT0MsYUFBYSxFQUFFQyxTQUFTLEVBQUUsR0FBR0wsT0FBT0MsT0FBTztZQUNuRUYsTUFBTWIsU0FBUyxHQUFHO1lBQ2xCYSxNQUFNWixVQUFVLEdBQUcsRUFBRTtZQUNyQlksTUFBTU4sZ0JBQWdCLEdBQUdZLFlBQ3JCO2dCQUNFLEdBQUdBLFNBQVM7Z0JBQ1p6QixVQUFVLFNBQTJCLE9BQWxCTjtnQkFDbkJnQyxXQUFXO1lBQ2IsSUFDQVo7WUFDSkssTUFBTVQsZ0JBQWdCLEdBQUc7WUFDekJTLE1BQU1SLE1BQU0sR0FBRztZQUNmUSxNQUFNUCxPQUFPLEdBQUc7WUFFaEIsSUFBSWUsZUFBeUIsRUFBRTtZ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dHVyZXMvZ2FtZVNsaWNlLnRzP2MwMWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU2xpY2UsIFBheWxvYWRBY3Rpb24gfSBmcm9tICdAcmVkdXhqcy90b29sa2l0J1xyXG5pbXBvcnQgeyBjYW5QbGF5Q2FyZCB9IGZyb20gJ0AvYm90cy1zZXJ2ZXIvQm90c1NlcnZlcidcclxuaW1wb3J0IHsgd3JhcE1vZCB9IGZyb20gJ0AvdXRpbHMvaGVscGVycydcclxuaW1wb3J0IHsgQ2FyZCwgUGxheWVyIH0gZnJvbSAnQC91dGlscy9pbnRlcmZhY2VzJ1xyXG5cclxuaW50ZXJmYWNlIFN0b3JlU3RhdGUge1xyXG4gIHBsYXllcklkOiBzdHJpbmdcclxuICBjdXJyZW50UGxheWVyOiBudW1iZXJcclxuICBuZXh0UGxheXJlOiBudW1iZXJcclxuICBvcmRlck9mZnNldDogbnVtYmVyXHJcbiAgZGlyZWN0aW9uOiBudW1iZXJcclxuICB0YWJsZVN0YWNrOiBDYXJkW11cclxuICBkcmF3aW5nU3RhY2s6IENhcmRbXVxyXG4gIHBsYXllcnM6IFBsYXllcltdXHJcbiAgbGFzdFBsYXllckRyYXdlZDogYm9vbGVhblxyXG4gIGluR2FtZTogYm9vbGVhblxyXG4gIGluTG9iYnk6IGJvb2xlYW5cclxuICBwZW5kaW5nRmlyc3RDYXJkPzogQ2FyZFxyXG59XHJcblxyXG5sZXQgY2FyZExheW91dElkSWR4ID0gMTExXHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZURyYXdpbmdDYXJkcyhjbnQ6IG51bWJlcikge1xyXG4gIHJldHVybiBBcnJheShjbnQpXHJcbiAgICAuZmlsbCgwKVxyXG4gICAgLm1hcCgoKSA9PiAoeyBsYXlvdXRJZDogYGlkXyR7Y2FyZExheW91dElkSWR4Kyt9YCB9KSlcclxufVxyXG5cclxuY29uc3QgaW5pdGlhbFN0YXRlOiBTdG9yZVN0YXRlID0ge1xyXG4gIHBsYXllcklkOiAnJyxcclxuICBjdXJyZW50UGxheWVyOiAwLFxyXG4gIG5leHRQbGF5cmU6IDAsXHJcbiAgb3JkZXJPZmZzZXQ6IDAsXHJcbiAgZGlyZWN0aW9uOiAxLFxyXG4gIHRhYmxlU3RhY2s6IFtdLFxyXG4gIGRyYXdpbmdTdGFjazogW10sXHJcbiAgcGxheWVyczogW10sXHJcbiAgbGFzdFBsYXllckRyYXdlZDogZmFsc2UsXHJcbiAgaW5HYW1lOiBmYWxzZSxcclxuICBpbkxvYmJ5OiBmYWxzZSxcclxuICBwZW5kaW5nRmlyc3RDYXJkOiB1bmRlZmluZWQsXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnYW1lU2xpY2UgPSBjcmVhdGVTbGljZSh7XHJcbiAgbmFtZTogJ2dhbWUnLFxyXG4gIGluaXRpYWxTdGF0ZSxcclxuICByZWR1Y2Vyczoge1xyXG4gICAgc2V0UGxheWVySWQoc3RhdGUsIGFjdGlvbjogUGF5bG9hZEFjdGlvbjxzdHJpbmc+KSB7XHJcbiAgICAgIHN0YXRlLnBsYXllcklkID0gYWN0aW9uLnBheWxvYWRcclxuICAgIH0sXHJcbiAgICBpbml0OiAoXHJcbiAgICAgIHN0YXRlLFxyXG4gICAgICBhY3Rpb246IFBheWxvYWRBY3Rpb248eyBwbGF5ZXJzOiBQbGF5ZXJbXTsgY2FyZHM6IENhcmRbXTsgZmlyc3RDYXJkPzogQ2FyZCB9PlxyXG4gICAgKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcGxheWVycywgY2FyZHM6IHN0YXJ0aW5nQ2FyZHMsIGZpcnN0Q2FyZCB9ID0gYWN0aW9uLnBheWxvYWRcclxuICAgICAgc3RhdGUuZGlyZWN0aW9uID0gMVxyXG4gICAgICBzdGF0ZS50YWJsZVN0YWNrID0gW11cclxuICAgICAgc3RhdGUucGVuZGluZ0ZpcnN0Q2FyZCA9IGZpcnN0Q2FyZFxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICAuLi5maXJzdENhcmQsXHJcbiAgICAgICAgICAgIGxheW91dElkOiBgdGFibGVfJHtjYXJkTGF5b3V0SWRJZHgrK31gLFxyXG4gICAgICAgICAgICByb3RhdGlvblk6IDAsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgOiB1bmRlZmluZWRcclxuICAgICAgc3RhdGUubGFzdFBsYXllckRyYXdlZCA9IGZhbHNlXHJcbiAgICAgIHN0YXRlLmluR2FtZSA9IHRydWVcclxuICAgICAgc3RhdGUuaW5Mb2JieSA9IGZhbHNlXHJcblxyXG4gICAgICBsZXQgcGxheWVyc0ZpbmFsOiBQbGF5ZXJbXSA9IFtdXHJcbiAgICAgIGxldCBteUlkeCA9IDBcclxuICAgICAgd2hpbGUgKG15SWR4IDwgcGxheWVycy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocGxheWVyc1tteUlkeF0uaWQgPT09IHN0YXRlLnBsYXllcklkKSBicmVha1xyXG4gICAgICAgIG15SWR4KytcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IG15SWR4OyBpIDwgcGxheWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBsYXllcnNGaW5hbC5wdXNoKHBsYXllcnNbaV0pXHJcbiAgICAgIH1cclxuICAgICAgc3RhdGUuY3VycmVudFBsYXllciA9IHBsYXllcnNGaW5hbC5sZW5ndGggJSBwbGF5ZXJzLmxlbmd0aFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG15SWR4OyBpKyspIHtcclxuICAgICAgICBwbGF5ZXJzRmluYWwucHVzaChwbGF5ZXJzW2ldKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgY2FyZHNUb0Rpc3RyaWJ1dGU6IENhcmRbXSA9IHN0YXJ0aW5nQ2FyZHMubWFwKChjKSA9PiAoe1xyXG4gICAgICAgIC4uLmMsXHJcbiAgICAgICAgbGF5b3V0SWQ6IGBpZF8ke2NhcmRMYXlvdXRJZElkeCsrfWAsXHJcbiAgICAgICAgcm90YXRpb25ZOiAwLFxyXG4gICAgICAgIHBsYXlhYmxlOiBteUlkeCA9PT0gMCxcclxuICAgICAgICBmb3JQbGF5ZXI6IDAsXHJcbiAgICAgIH0pKVxyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwbGF5ZXJzRmluYWwubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjYXJkc1RvRGlzdHJpYnV0ZSA9IGNhcmRzVG9EaXN0cmlidXRlLmNvbmNhdChcclxuICAgICAgICAgIEFycmF5KHN0YXJ0aW5nQ2FyZHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAuZmlsbCgwKVxyXG4gICAgICAgICAgICAubWFwKCgpID0+ICh7XHJcbiAgICAgICAgICAgICAgbGF5b3V0SWQ6IGBpZF8ke2NhcmRMYXlvdXRJZElkeCsrfWAsXHJcbiAgICAgICAgICAgICAgZm9yUGxheWVyOiBpLFxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICApXHJcbiAgICAgIH1cclxuICAgICAgc3RhdGUucGxheWVycyA9IHBsYXllcnNGaW5hbFxyXG4gICAgICBzdGF0ZS5kcmF3aW5nU3RhY2sgPSBjYXJkc1RvRGlzdHJpYnV0ZS5jb25jYXQoZ2VuZXJhdGVEcmF3aW5nQ2FyZHMoMjApKVxyXG4gICAgICBzdGF0ZS5vcmRlck9mZnNldCA9IG15SWR4XHJcbiAgICB9LFxyXG5cclxuICAgIHJlYWR5KHN0YXRlKSB7XHJcbiAgICAgIHN0YXRlLnBsYXllcnMgPSBzdGF0ZS5wbGF5ZXJzLm1hcCgocGxheWVyLCBpZHgpID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgLi4ucGxheWVyLFxyXG4gICAgICAgICAgY2FyZHM6IHN0YXRlLmRyYXdpbmdTdGFjay5maWx0ZXIoKGMpID0+IGMuZm9yUGxheWVyID09PSBpZHgpLFxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIHN0YXRlLmRyYXdpbmdTdGFjayA9IHN0YXRlLmRyYXdpbmdTdGFjay5maWx0ZXIoXHJcbiAgICAgICAgKGMpID0+IHR5cGVvZiBjLmZvclBsYXllciA9PT0gJ3VuZGVmaW5lZCdcclxuICAgICAgKVxyXG5cclxuICAgICAgaWYgKCFzdGF0ZS50YWJsZVN0YWNrLmxlbmd0aCAmJiBzdGF0ZS5wZW5kaW5nRmlyc3RDYXJkKSB7XHJcbiAgICAgICAgc3RhdGUudGFibGVTdGFjayA9IFtzdGF0ZS5wZW5kaW5nRmlyc3RDYXJkXVxyXG4gICAgICAgIHN0YXRlLnBlbmRpbmdGaXJzdENhcmQgPSB1bmRlZmluZWRcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wR2FtZShzdGF0ZSkge1xyXG4gICAgICBzdGF0ZS5pbkdhbWUgPSBmYWxzZVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRJbkxvYmJ5KHN0YXRlLCBhY3Rpb246IFBheWxvYWRBY3Rpb248Ym9vbGVhbj4pIHtcclxuICAgICAgc3RhdGUuaW5Mb2JieSA9IGFjdGlvbi5wYXlsb2FkXHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVDYXJkKFxyXG4gICAgICBzdGF0ZSxcclxuICAgICAgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPHtcclxuICAgICAgICBjdXJQbGF5ZXI6IG51bWJlclxyXG4gICAgICAgIG5leHRQbGF5ZXI6IG51bWJlclxyXG4gICAgICAgIGNhcmQ/OiBDYXJkXHJcbiAgICAgICAgZHJhdz86IG51bWJlclxyXG4gICAgICAgIGNhcmRzVG9EcmF3PzogQ2FyZFtdXHJcbiAgICAgIH0+XHJcbiAgICApIHtcclxuICAgICAgbGV0IHsgY3VyUGxheWVyLCBuZXh0UGxheWVyLCBjYXJkLCBjYXJkc1RvRHJhdyA9IFtdLCBkcmF3IH0gPSBhY3Rpb24ucGF5bG9hZFxyXG5cclxuICAgICAgLy8gQ29udmVydCBjdXJQbGF5ZXIgZnJvbSBzZXJ2ZXIgaW5kZXggdG8gVUkgaW5kZXhcclxuICAgICAgY3VyUGxheWVyID0gd3JhcE1vZChjdXJQbGF5ZXIgLSBzdGF0ZS5vcmRlck9mZnNldCwgc3RhdGUucGxheWVycy5sZW5ndGgpXHJcblxyXG4gICAgICBjb25zdCBjdXJQbGF5ZXJPYmogPSBzdGF0ZS5wbGF5ZXJzW2N1clBsYXllcl1cclxuXHJcbiAgICAgIG5leHRQbGF5ZXIgPSB3cmFwTW9kKG5leHRQbGF5ZXIgLSBzdGF0ZS5vcmRlck9mZnNldCwgc3RhdGUucGxheWVycy5sZW5ndGgpXHJcblxyXG4gICAgICBpZiAoY2FyZD8uYWN0aW9uID09PSAncmV2ZXJzZScpIHN0YXRlLmRpcmVjdGlvbiAqPSAtMVxyXG5cclxuICAgICAgaWYgKGRyYXcpIHtcclxuICAgICAgICBzdGF0ZS5wbGF5ZXJzID0gc3RhdGUucGxheWVycy5tYXAoKHApID0+IHtcclxuICAgICAgICAgIGlmIChwLmlkID09PSBjdXJQbGF5ZXJPYmouaWQpIHtcclxuICAgICAgICAgICAgbGV0IG5ld0NhcmRzID0gc3RhdGUuZHJhd2luZ1N0YWNrLnNsaWNlKDAsIGRyYXcpXHJcbiAgICAgICAgICAgIGlmIChjdXJQbGF5ZXJPYmouaWQgPT09IHN0YXRlLnBsYXllcklkICYmIGNhcmRzVG9EcmF3KSB7XHJcbiAgICAgICAgICAgICAgbmV3Q2FyZHMgPSBuZXdDYXJkcy5tYXAoKGMsIGlkeCkgPT4gKHtcclxuICAgICAgICAgICAgICAgIC4uLmMsXHJcbiAgICAgICAgICAgICAgICAuLi5jYXJkc1RvRHJhd1tpZHhdLFxyXG4gICAgICAgICAgICAgICAgcm90YXRpb25ZOiAwLFxyXG4gICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICBjYXJkczogcC5jYXJkcy5jb25jYXQobmV3Q2FyZHMpLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgc3RhdGUuZHJhd2luZ1N0YWNrID0gc3RhdGUuZHJhd2luZ1N0YWNrXHJcbiAgICAgICAgICAuc2xpY2UoZHJhdylcclxuICAgICAgICAgIC5jb25jYXQoZ2VuZXJhdGVEcmF3aW5nQ2FyZHMoZHJhdykpXHJcbiAgICAgICAgc3RhdGUubGFzdFBsYXllckRyYXdlZCA9IHRydWVcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhcmQpIHtcclxuICAgICAgICBsZXQgbGF5b3V0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9ICcnXHJcbiAgICAgICAgbGV0IHNob3VsZEZsaXAgPSBmYWxzZVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiBwbGF5ZXIgYWN0dWFsbHkgaGFzIHRoZSBjYXJkIChvciBhbnkgY2FyZCBpZiBub3QgbG9jYWwgcGxheWVyKVxyXG4gICAgICAgIGNvbnN0IGhhc0NhcmQgPSBjdXJQbGF5ZXJPYmouY2FyZHMuc29tZSgoYykgPT5cclxuICAgICAgICAgIGN1clBsYXllck9iai5pZCA9PT0gc3RhdGUucGxheWVySWQgPyBjLmlkID09PSBjYXJkPy5pZCA6IHRydWVcclxuICAgICAgICApXHJcblxyXG4gICAgICAgIGlmIChoYXNDYXJkICYmIGN1clBsYXllck9iai5jYXJkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBpZiAoY3VyUGxheWVyT2JqLmlkICE9PSBzdGF0ZS5wbGF5ZXJJZCkge1xyXG4gICAgICAgICAgICBsYXlvdXRJZCA9XHJcbiAgICAgICAgICAgICAgY3VyUGxheWVyT2JqLmNhcmRzW1xyXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3VyUGxheWVyT2JqLmNhcmRzLmxlbmd0aClcclxuICAgICAgICAgICAgICBdLmxheW91dElkXHJcbiAgICAgICAgICAgIHNob3VsZEZsaXAgPSB0cnVlXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsYXlvdXRJZCA9IGN1clBsYXllck9iai5jYXJkcy5maW5kKChjKSA9PiBjLmlkID09PSBjYXJkPy5pZCk/LmxheW91dElkXHJcbiAgICAgICAgICAgIGNvbnN0IGNhcmRUb01vdmUgPSBjdXJQbGF5ZXJPYmouY2FyZHMuZmlsdGVyKFxyXG4gICAgICAgICAgICAgIChjKSA9PiBjLmxheW91dElkID09PSBsYXlvdXRJZFxyXG4gICAgICAgICAgICApWzBdXHJcblxyXG4gICAgICAgICAgICBpZiAoY2FyZFRvTW92ZSkge1xyXG4gICAgICAgICAgICAgIGNhcmQuY29sb3IgPSBjYXJkVG9Nb3ZlLmNvbG9yXHJcbiAgICAgICAgICAgICAgY2FyZC5hY3Rpb24gPSBjYXJkVG9Nb3ZlLmFjdGlvblxyXG4gICAgICAgICAgICAgIGNhcmQuZGlnaXQgPSBjYXJkVG9Nb3ZlLmRpZ2l0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gQ2FyZCBub3QgaW4gaGFuZCAoZS5nLiBmaXJzdCBjYXJkIHBsYXllZCBieSBzeXN0ZW0pXHJcbiAgICAgICAgICAvLyBBbmltYXRlIGZyb20gZHJhd2luZyBzdGFjayAoZGVjaylcclxuICAgICAgICAgIGxheW91dElkID0gYHN5c3RlbV9tb3ZlXyR7Y2FyZExheW91dElkSWR4Kyt9YFxyXG4gICAgICAgICAgc2hvdWxkRmxpcCA9IHRydWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRlLnRhYmxlU3RhY2sgPSBbXHJcbiAgICAgICAgICAuLi5zdGF0ZS50YWJsZVN0YWNrLnNsaWNlKC0xKSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbGF5b3V0SWQ6IGxheW91dElkIHx8IGB1bmtub3duXyR7Y2FyZExheW91dElkSWR4Kyt9YCxcclxuICAgICAgICAgICAgY29sb3I6IGNhcmQuY29sb3IsXHJcbiAgICAgICAgICAgIGFjdGlvbjogY2FyZC5hY3Rpb24sXHJcbiAgICAgICAgICAgIGRpZ2l0OiBjYXJkLmRpZ2l0LFxyXG4gICAgICAgICAgICBmbGlwOiBzaG91bGRGbGlwLFxyXG4gICAgICAgICAgICByb3RhdGlvblk6IDAsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF1cclxuXHJcbiAgICAgICAgLy8gT25seSByZW1vdmUgY2FyZCBpZiBpdCB3YXMgaW4gaGFuZFxyXG4gICAgICAgIGlmIChoYXNDYXJkKSB7XHJcbiAgICAgICAgICBzdGF0ZS5wbGF5ZXJzID0gc3RhdGUucGxheWVycy5tYXAoKHApID0+IHtcclxuICAgICAgICAgICAgaWYgKHAgPT09IGN1clBsYXllck9iaikge1xyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5wLFxyXG4gICAgICAgICAgICAgICAgY2FyZHM6IHAuY2FyZHMuZmlsdGVyKChjKSA9PiBjLmxheW91dElkICE9PSBsYXlvdXRJZCksXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5sYXN0UGxheWVyRHJhd2VkID0gZmFsc2VcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RhdGUubmV4dFBsYXlyZSA9IG5leHRQbGF5ZXJcclxuICAgIH0sXHJcbiAgICBtb3ZlUGxheWVyKHN0YXRlKSB7XHJcbiAgICAgIHN0YXRlLnBsYXllcnMgPSBzdGF0ZS5wbGF5ZXJzLm1hcCgocCkgPT4ge1xyXG4gICAgICAgIGlmIChwLmlkID09PSBzdGF0ZS5wbGF5ZXJJZCkge1xyXG4gICAgICAgICAgY29uc3QgbXlUdXJuID0gc3RhdGUubmV4dFBsYXlyZSA9PT0gMFxyXG5cclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgIGNhcmRzOiBwLmNhcmRzLm1hcCgoYykgPT4ge1xyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5jLFxyXG4gICAgICAgICAgICAgICAgcGxheWFibGU6XHJcbiAgICAgICAgICAgICAgICAgIG15VHVybiAmJlxyXG4gICAgICAgICAgICAgICAgICBjYW5QbGF5Q2FyZChcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50YWJsZVN0YWNrW3N0YXRlLnRhYmxlU3RhY2subGVuZ3RoIC0gMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgYyxcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5sYXN0UGxheWVyRHJhd2VkXHJcbiAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBcclxuICAgICAgfSlcclxuICAgICAgc3RhdGUuY3VycmVudFBsYXllciA9IHN0YXRlLm5leHRQbGF5cmVcclxuICAgIH0sXHJcbiAgfSxcclxufSlcclxuXHJcbmV4cG9ydCBjb25zdCB7XHJcbiAgaW5pdCxcclxuICByZWFkeSxcclxuICBzdG9wR2FtZSxcclxuICBtb3ZlQ2FyZCxcclxuICBtb3ZlUGxheWVyLFxyXG4gIHNldEluTG9iYnksXHJcbiAgc2V0UGxheWVySWQsXHJcbn0gPSBnYW1lU2xpY2UuYWN0aW9uc1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2FtZVNsaWNlLnJlZHVjZXJcclxuXHJcblxyXG4iXSwibmFtZXMiOlsiY3JlYXRlU2xpY2UiLCJjYW5QbGF5Q2FyZCIsIndyYXBNb2QiLCJjYXJkTGF5b3V0SWRJZHgiLCJnZW5lcmF0ZURyYXdpbmdDYXJkcyIsImNudCIsIkFycmF5IiwiZmlsbCIsIm1hcCIsImxheW91dElkIiwiaW5pdGlhbFN0YXRlIiwicGxheWVySWQiLCJjdXJyZW50UGxheWVyIiwibmV4dFBsYXlyZSIsIm9yZGVyT2Zmc2V0IiwiZGlyZWN0aW9uIiwidGFibGVTdGFjayIsImRyYXdpbmdTdGFjayIsInBsYXllcnMiLCJsYXN0UGxheWVyRHJhd2VkIiwiaW5HYW1lIiwiaW5Mb2JieSIsInBlbmRpbmdGaXJzdENhcmQiLCJ1bmRlZmluZWQiLCJnYW1lU2xpY2UiLCJuYW1lIiwicmVkdWNlcnMiLCJzZXRQbGF5ZXJJZCIsInN0YXRlIiwiYWN0aW9uIiwicGF5bG9hZCIsImluaXQiLCJjYXJkcyIsInN0YXJ0aW5nQ2FyZHMiLCJmaXJzdENhcmQiLCJyb3RhdGlvblkiLCJwbGF5ZXJzRmluYWwiLCJteUlkeCIsImxlbmd0aCIsImlkIiwiaSIsInB1c2giLCJjYXJkc1RvRGlzdHJpYnV0ZSIsImMiLCJwbGF5YWJsZSIsImZvclBsYXllciIsImNvbmNhdCIsInJlYWR5IiwicGxheWVyIiwiaWR4IiwiZmlsdGVyIiwic3RvcEdhbWUiLCJzZXRJbkxvYmJ5IiwibW92ZUNhcmQiLCJjdXJQbGF5ZXIiLCJuZXh0UGxheWVyIiwiY2FyZCIsImNhcmRzVG9EcmF3IiwiZHJhdyIsImN1clBsYXllck9iaiIsInAiLCJuZXdDYXJkcyIsInNsaWNlIiwic2hvdWxkRmxpcCIsImhhc0NhcmQiLCJzb21lIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZmluZCIsImNhcmRUb01vdmUiLCJjb2xvciIsImRpZ2l0IiwiZmxpcCIsIm1vdmVQbGF5ZXIiLCJteVR1cm4iLCJhY3Rpb25zIiwicmVkdWNlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./stores/features/gameSlice.ts\n"));

/***/ })

});