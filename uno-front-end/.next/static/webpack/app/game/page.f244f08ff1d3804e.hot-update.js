"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/game/page",{

/***/ "(app-pages-browser)/./stores/features/gameSlice.ts":
/*!**************************************!*\
  !*** ./stores/features/gameSlice.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gameSlice: function() { return /* binding */ gameSlice; },\n/* harmony export */   init: function() { return /* binding */ init; },\n/* harmony export */   moveCard: function() { return /* binding */ moveCard; },\n/* harmony export */   movePlayer: function() { return /* binding */ movePlayer; },\n/* harmony export */   ready: function() { return /* binding */ ready; },\n/* harmony export */   setInLobby: function() { return /* binding */ setInLobby; },\n/* harmony export */   setPlayerId: function() { return /* binding */ setPlayerId; },\n/* harmony export */   stopGame: function() { return /* binding */ stopGame; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _bots_server_BotsServer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/bots-server/BotsServer */ \"(app-pages-browser)/./bots-server/BotsServer.ts\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/helpers */ \"(app-pages-browser)/./utils/helpers.ts\");\n\n\n\nlet cardLayoutIdIdx = 111;\nfunction generateDrawingCards(cnt) {\n    return Array(cnt).fill(0).map(()=>({\n            layoutId: \"id_\".concat(cardLayoutIdIdx++)\n        }));\n}\nconst initialState = {\n    playerId: \"\",\n    currentPlayer: 0,\n    nextPlayre: 0,\n    orderOffset: 0,\n    direction: 1,\n    tableStack: [],\n    drawingStack: [],\n    players: [],\n    lastPlayerDrawed: false,\n    inGame: false,\n    inLobby: false\n};\nconst gameSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__.createSlice)({\n    name: \"game\",\n    initialState,\n    reducers: {\n        setPlayerId (state, action) {\n            state.playerId = action.payload;\n        },\n        init: (state, action)=>{\n            const { players, cards: startingCards, firstCard } = action.payload;\n            state.direction = 1;\n            state.tableStack = firstCard ? [\n                {\n                    ...firstCard,\n                    layoutId: \"table_\".concat(cardLayoutIdIdx++),\n                    rotationY: 0\n                }\n            ] : [];\n            state.lastPlayerDrawed = false;\n            state.inGame = true;\n            state.inLobby = false;\n            let playersFinal = [];\n            let myIdx = 0;\n            while(myIdx < players.length){\n                if (players[myIdx].id === state.playerId) break;\n                myIdx++;\n            }\n            for(let i = myIdx; i < players.length; i++){\n                playersFinal.push(players[i]);\n            }\n            state.currentPlayer = playersFinal.length % players.length;\n            for(let i = 0; i < myIdx; i++){\n                playersFinal.push(players[i]);\n            }\n            let cardsToDistribute = startingCards.map((c)=>({\n                    ...c,\n                    layoutId: \"id_\".concat(cardLayoutIdIdx++),\n                    rotationY: 0,\n                    playable: myIdx === 0,\n                    forPlayer: 0\n                }));\n            for(let i = 1; i < playersFinal.length; i++){\n                cardsToDistribute = cardsToDistribute.concat(Array(startingCards.length).fill(0).map(()=>({\n                        layoutId: \"id_\".concat(cardLayoutIdIdx++),\n                        forPlayer: i\n                    })));\n            }\n            state.players = playersFinal;\n            state.drawingStack = cardsToDistribute.concat(generateDrawingCards(20));\n            state.orderOffset = myIdx;\n        },\n        ready (state) {\n            state.players = state.players.map((player, idx)=>{\n                return {\n                    ...player,\n                    cards: state.drawingStack.filter((c)=>c.forPlayer === idx)\n                };\n            });\n            state.drawingStack = state.drawingStack.filter((c)=>typeof c.forPlayer === \"undefined\");\n        },\n        stopGame (state) {\n            state.inGame = false;\n        },\n        setInLobby (state, action) {\n            state.inLobby = action.payload;\n        },\n        moveCard (state, action) {\n            let { nextPlayer, card, cardsToDraw = [], draw } = action.payload;\n            const curPlayerObj = state.players[state.currentPlayer];\n            nextPlayer = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.wrapMod)(nextPlayer - state.orderOffset, state.players.length);\n            if ((card === null || card === void 0 ? void 0 : card.action) === \"reverse\") state.direction *= -1;\n            if (draw) {\n                state.players = state.players.map((p)=>{\n                    if (p.id === curPlayerObj.id) {\n                        let newCards = state.drawingStack.slice(0, draw);\n                        if (curPlayerObj.id === state.playerId && cardsToDraw) {\n                            newCards = newCards.map((c, idx)=>({\n                                    ...c,\n                                    ...cardsToDraw[idx],\n                                    rotationY: 0\n                                }));\n                        }\n                        return {\n                            ...p,\n                            cards: p.cards.concat(newCards)\n                        };\n                    }\n                    return p;\n                });\n                state.drawingStack = state.drawingStack.slice(draw).concat(generateDrawingCards(draw));\n                state.lastPlayerDrawed = true;\n            }\n            if (card) {\n                let layoutId = \"\";\n                let shouldFlip = false;\n                // Check if player actually has the card (or any card if not local player)\n                const hasCard = curPlayerObj.cards.some((c)=>curPlayerObj.id === state.playerId ? c.id === (card === null || card === void 0 ? void 0 : card.id) : true);\n                if (hasCard && curPlayerObj.cards.length > 0) {\n                    if (curPlayerObj.id !== state.playerId) {\n                        layoutId = curPlayerObj.cards[Math.floor(Math.random() * curPlayerObj.cards.length)].layoutId;\n                        shouldFlip = true;\n                    } else {\n                        var _curPlayerObj_cards_find;\n                        layoutId = (_curPlayerObj_cards_find = curPlayerObj.cards.find((c)=>c.id === (card === null || card === void 0 ? void 0 : card.id))) === null || _curPlayerObj_cards_find === void 0 ? void 0 : _curPlayerObj_cards_find.layoutId;\n                        const cardToMove = curPlayerObj.cards.filter((c)=>c.layoutId === layoutId)[0];\n                        if (cardToMove) {\n                            card.color = cardToMove.color;\n                            card.action = cardToMove.action;\n                            card.digit = cardToMove.digit;\n                        }\n                    }\n                } else {\n                    // Card not in hand (e.g. first card played by system)\n                    // Animate from drawing stack (deck)\n                    layoutId = \"system_move_\".concat(cardLayoutIdIdx++);\n                    shouldFlip = true;\n                }\n                state.tableStack = [\n                    ...state.tableStack.slice(-1),\n                    {\n                        layoutId: layoutId || \"unknown_\".concat(cardLayoutIdIdx++),\n                        color: card.color,\n                        action: card.action,\n                        digit: card.digit,\n                        flip: shouldFlip,\n                        rotationY: 0\n                    }\n                ];\n                // Only remove card if it was in hand\n                if (hasCard) {\n                    state.players = state.players.map((p)=>{\n                        if (p === curPlayerObj) {\n                            return {\n                                ...p,\n                                cards: p.cards.filter((c)=>c.layoutId !== layoutId)\n                            };\n                        }\n                        return p;\n                    });\n                }\n                state.lastPlayerDrawed = false;\n            }\n            state.nextPlayre = nextPlayer;\n        },\n        movePlayer (state) {\n            state.players = state.players.map((p)=>{\n                if (p.id === state.playerId) {\n                    const myTurn = state.nextPlayre === 0;\n                    return {\n                        ...p,\n                        cards: p.cards.map((c)=>{\n                            return {\n                                ...c,\n                                playable: myTurn && (0,_bots_server_BotsServer__WEBPACK_IMPORTED_MODULE_0__.canPlayCard)(state.tableStack[state.tableStack.length - 1], c, state.lastPlayerDrawed)\n                            };\n                        })\n                    };\n                }\n                return p;\n            });\n            state.currentPlayer = state.nextPlayre;\n        }\n    }\n});\nconst { init, ready, stopGame, moveCard, movePlayer, setInLobby, setPlayerId } = gameSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (gameSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3Jlcy9mZWF0dXJlcy9nYW1lU2xpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDUDtBQUNiO0FBaUJ6QyxJQUFJRyxrQkFBa0I7QUFFdEIsU0FBU0MscUJBQXFCQyxHQUFXO0lBQ3ZDLE9BQU9DLE1BQU1ELEtBQ1ZFLElBQUksQ0FBQyxHQUNMQyxHQUFHLENBQUMsSUFBTztZQUFFQyxVQUFVLE1BQXdCLE9BQWxCTjtRQUFvQjtBQUN0RDtBQUVBLE1BQU1PLGVBQTJCO0lBQy9CQyxVQUFVO0lBQ1ZDLGVBQWU7SUFDZkMsWUFBWTtJQUNaQyxhQUFhO0lBQ2JDLFdBQVc7SUFDWEMsWUFBWSxFQUFFO0lBQ2RDLGNBQWMsRUFBRTtJQUNoQkMsU0FBUyxFQUFFO0lBQ1hDLGtCQUFrQjtJQUNsQkMsUUFBUTtJQUNSQyxTQUFTO0FBQ1g7QUFFTyxNQUFNQyxZQUFZdEIsNkRBQVdBLENBQUM7SUFDbkN1QixNQUFNO0lBQ05iO0lBQ0FjLFVBQVU7UUFDUkMsYUFBWUMsS0FBSyxFQUFFQyxNQUE2QjtZQUM5Q0QsTUFBTWYsUUFBUSxHQUFHZ0IsT0FBT0MsT0FBTztRQUNqQztRQUNBQyxNQUFNLENBQ0pILE9BQ0FDO1lBRUEsTUFBTSxFQUFFVCxPQUFPLEVBQUVZLE9BQU9DLGFBQWEsRUFBRUMsU0FBUyxFQUFFLEdBQUdMLE9BQU9DLE9BQU87WUFDbkVGLE1BQU1YLFNBQVMsR0FBRztZQUNsQlcsTUFBTVYsVUFBVSxHQUFHZ0IsWUFBWTtnQkFBQztvQkFDOUIsR0FBR0EsU0FBUztvQkFDWnZCLFVBQVUsU0FBMkIsT0FBbEJOO29CQUNuQjhCLFdBQVc7Z0JBQ2I7YUFBRSxHQUFHLEVBQUU7WUFDUFAsTUFBTVAsZ0JBQWdCLEdBQUc7WUFDekJPLE1BQU1OLE1BQU0sR0FBRztZQUNmTSxNQUFNTCxPQUFPLEdBQUc7WUFFaEIsSUFBSWEsZUFBeUIsRUFBRTtZQUMvQixJQUFJQyxRQUFRO1lBQ1osTUFBT0EsUUFB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LEdBQUdRLE1BQU1SLE9BQU8sQ0FBQ1YsR0FBRyxDQUFDLENBQUNpRDtnQkFDakMsSUFBSUEsRUFBRXBCLEVBQUUsS0FBS1gsTUFBTWYsUUFBUSxFQUFFO29CQUMzQixNQUFNNkQsU0FBUzlDLE1BQU1iLFVBQVUsS0FBSztvQkFFcEMsT0FBTzt3QkFDTCxHQUFHNEMsQ0FBQzt3QkFDSjNCLE9BQU8yQixFQUFFM0IsS0FBSyxDQUFDdEIsR0FBRyxDQUFDLENBQUNpQzs0QkFDbEIsT0FBTztnQ0FDTCxHQUFHQSxDQUFDO2dDQUNKQyxVQUNFOEIsVUFDQXZFLG9FQUFXQSxDQUNUeUIsTUFBTVYsVUFBVSxDQUFDVSxNQUFNVixVQUFVLENBQUNvQixNQUFNLEdBQUcsRUFBRSxFQUM3Q0ssR0FDQWYsTUFBTVAsZ0JBQWdCOzRCQUU1Qjt3QkFDRjtvQkFDRjtnQkFDRjtnQkFDQSxPQUFPc0M7WUFDVDtZQUNBL0IsTUFBTWQsYUFBYSxHQUFHYyxNQUFNYixVQUFVO1FBQ3hDO0lBQ0Y7QUFDRixHQUFFO0FBRUssTUFBTSxFQUNYZ0IsSUFBSSxFQUNKZ0IsS0FBSyxFQUNMSSxRQUFRLEVBQ1JFLFFBQVEsRUFDUm9CLFVBQVUsRUFDVnJCLFVBQVUsRUFDVnpCLFdBQVcsRUFDWixHQUFHSCxVQUFVbUQsT0FBTztBQUVyQiwrREFBZW5ELFVBQVVvRCxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0b3Jlcy9mZWF0dXJlcy9nYW1lU2xpY2UudHM/YzAxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTbGljZSwgUGF5bG9hZEFjdGlvbiB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnXHJcbmltcG9ydCB7IGNhblBsYXlDYXJkIH0gZnJvbSAnQC9ib3RzLXNlcnZlci9Cb3RzU2VydmVyJ1xyXG5pbXBvcnQgeyB3cmFwTW9kIH0gZnJvbSAnQC91dGlscy9oZWxwZXJzJ1xyXG5pbXBvcnQgeyBDYXJkLCBQbGF5ZXIgfSBmcm9tICdAL3V0aWxzL2ludGVyZmFjZXMnXHJcblxyXG5pbnRlcmZhY2UgU3RvcmVTdGF0ZSB7XHJcbiAgcGxheWVySWQ6IHN0cmluZ1xyXG4gIGN1cnJlbnRQbGF5ZXI6IG51bWJlclxyXG4gIG5leHRQbGF5cmU6IG51bWJlclxyXG4gIG9yZGVyT2Zmc2V0OiBudW1iZXJcclxuICBkaXJlY3Rpb246IG51bWJlclxyXG4gIHRhYmxlU3RhY2s6IENhcmRbXVxyXG4gIGRyYXdpbmdTdGFjazogQ2FyZFtdXHJcbiAgcGxheWVyczogUGxheWVyW11cclxuICBsYXN0UGxheWVyRHJhd2VkOiBib29sZWFuXHJcbiAgaW5HYW1lOiBib29sZWFuXHJcbiAgaW5Mb2JieTogYm9vbGVhblxyXG59XHJcblxyXG5sZXQgY2FyZExheW91dElkSWR4ID0gMTExXHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZURyYXdpbmdDYXJkcyhjbnQ6IG51bWJlcikge1xyXG4gIHJldHVybiBBcnJheShjbnQpXHJcbiAgICAuZmlsbCgwKVxyXG4gICAgLm1hcCgoKSA9PiAoeyBsYXlvdXRJZDogYGlkXyR7Y2FyZExheW91dElkSWR4Kyt9YCB9KSlcclxufVxyXG5cclxuY29uc3QgaW5pdGlhbFN0YXRlOiBTdG9yZVN0YXRlID0ge1xyXG4gIHBsYXllcklkOiAnJyxcclxuICBjdXJyZW50UGxheWVyOiAwLFxyXG4gIG5leHRQbGF5cmU6IDAsXHJcbiAgb3JkZXJPZmZzZXQ6IDAsXHJcbiAgZGlyZWN0aW9uOiAxLFxyXG4gIHRhYmxlU3RhY2s6IFtdLFxyXG4gIGRyYXdpbmdTdGFjazogW10sXHJcbiAgcGxheWVyczogW10sXHJcbiAgbGFzdFBsYXllckRyYXdlZDogZmFsc2UsXHJcbiAgaW5HYW1lOiBmYWxzZSxcclxuICBpbkxvYmJ5OiBmYWxzZSxcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdhbWVTbGljZSA9IGNyZWF0ZVNsaWNlKHtcclxuICBuYW1lOiAnZ2FtZScsXHJcbiAgaW5pdGlhbFN0YXRlLFxyXG4gIHJlZHVjZXJzOiB7XHJcbiAgICBzZXRQbGF5ZXJJZChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPHN0cmluZz4pIHtcclxuICAgICAgc3RhdGUucGxheWVySWQgPSBhY3Rpb24ucGF5bG9hZFxyXG4gICAgfSxcclxuICAgIGluaXQ6IChcclxuICAgICAgc3RhdGUsXHJcbiAgICAgIGFjdGlvbjogUGF5bG9hZEFjdGlvbjx7IHBsYXllcnM6IFBsYXllcltdOyBjYXJkczogQ2FyZFtdOyBmaXJzdENhcmQ/OiBDYXJkIH0+XHJcbiAgICApID0+IHtcclxuICAgICAgY29uc3QgeyBwbGF5ZXJzLCBjYXJkczogc3RhcnRpbmdDYXJkcywgZmlyc3RDYXJkIH0gPSBhY3Rpb24ucGF5bG9hZFxyXG4gICAgICBzdGF0ZS5kaXJlY3Rpb24gPSAxXHJcbiAgICAgIHN0YXRlLnRhYmxlU3RhY2sgPSBmaXJzdENhcmQgPyBbe1xyXG4gICAgICAgIC4uLmZpcnN0Q2FyZCxcclxuICAgICAgICBsYXlvdXRJZDogYHRhYmxlXyR7Y2FyZExheW91dElkSWR4Kyt9YCxcclxuICAgICAgICByb3RhdGlvblk6IDAsXHJcbiAgICAgIH1dIDogW11cclxuICAgICAgc3RhdGUubGFzdFBsYXllckRyYXdlZCA9IGZhbHNlXHJcbiAgICAgIHN0YXRlLmluR2FtZSA9IHRydWVcclxuICAgICAgc3RhdGUuaW5Mb2JieSA9IGZhbHNlXHJcblxyXG4gICAgICBsZXQgcGxheWVyc0ZpbmFsOiBQbGF5ZXJbXSA9IFtdXHJcbiAgICAgIGxldCBteUlkeCA9IDBcclxuICAgICAgd2hpbGUgKG15SWR4IDwgcGxheWVycy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocGxheWVyc1tteUlkeF0uaWQgPT09IHN0YXRlLnBsYXllcklkKSBicmVha1xyXG4gICAgICAgIG15SWR4KytcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IG15SWR4OyBpIDwgcGxheWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBsYXllcnNGaW5hbC5wdXNoKHBsYXllcnNbaV0pXHJcbiAgICAgIH1cclxuICAgICAgc3RhdGUuY3VycmVudFBsYXllciA9IHBsYXllcnNGaW5hbC5sZW5ndGggJSBwbGF5ZXJzLmxlbmd0aFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG15SWR4OyBpKyspIHtcclxuICAgICAgICBwbGF5ZXJzRmluYWwucHVzaChwbGF5ZXJzW2ldKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgY2FyZHNUb0Rpc3RyaWJ1dGU6IENhcmRbXSA9IHN0YXJ0aW5nQ2FyZHMubWFwKChjKSA9PiAoe1xyXG4gICAgICAgIC4uLmMsXHJcbiAgICAgICAgbGF5b3V0SWQ6IGBpZF8ke2NhcmRMYXlvdXRJZElkeCsrfWAsXHJcbiAgICAgICAgcm90YXRpb25ZOiAwLFxyXG4gICAgICAgIHBsYXlhYmxlOiBteUlkeCA9PT0gMCxcclxuICAgICAgICBmb3JQbGF5ZXI6IDAsXHJcbiAgICAgIH0pKVxyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwbGF5ZXJzRmluYWwubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjYXJkc1RvRGlzdHJpYnV0ZSA9IGNhcmRzVG9EaXN0cmlidXRlLmNvbmNhdChcclxuICAgICAgICAgIEFycmF5KHN0YXJ0aW5nQ2FyZHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAuZmlsbCgwKVxyXG4gICAgICAgICAgICAubWFwKCgpID0+ICh7XHJcbiAgICAgICAgICAgICAgbGF5b3V0SWQ6IGBpZF8ke2NhcmRMYXlvdXRJZElkeCsrfWAsXHJcbiAgICAgICAgICAgICAgZm9yUGxheWVyOiBpLFxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICApXHJcbiAgICAgIH1cclxuICAgICAgc3RhdGUucGxheWVycyA9IHBsYXllcnNGaW5hbFxyXG4gICAgICBzdGF0ZS5kcmF3aW5nU3RhY2sgPSBjYXJkc1RvRGlzdHJpYnV0ZS5jb25jYXQoZ2VuZXJhdGVEcmF3aW5nQ2FyZHMoMjApKVxyXG4gICAgICBzdGF0ZS5vcmRlck9mZnNldCA9IG15SWR4XHJcbiAgICB9LFxyXG5cclxuICAgIHJlYWR5KHN0YXRlKSB7XHJcbiAgICAgIHN0YXRlLnBsYXllcnMgPSBzdGF0ZS5wbGF5ZXJzLm1hcCgocGxheWVyLCBpZHgpID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgLi4ucGxheWVyLFxyXG4gICAgICAgICAgY2FyZHM6IHN0YXRlLmRyYXdpbmdTdGFjay5maWx0ZXIoKGMpID0+IGMuZm9yUGxheWVyID09PSBpZHgpLFxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIHN0YXRlLmRyYXdpbmdTdGFjayA9IHN0YXRlLmRyYXdpbmdTdGFjay5maWx0ZXIoXHJcbiAgICAgICAgKGMpID0+IHR5cGVvZiBjLmZvclBsYXllciA9PT0gJ3VuZGVmaW5lZCdcclxuICAgICAgKVxyXG4gICAgfSxcclxuXHJcbiAgICBzdG9wR2FtZShzdGF0ZSkge1xyXG4gICAgICBzdGF0ZS5pbkdhbWUgPSBmYWxzZVxyXG4gICAgfSxcclxuXHJcbiAgICBzZXRJbkxvYmJ5KHN0YXRlLCBhY3Rpb246IFBheWxvYWRBY3Rpb248Ym9vbGVhbj4pIHtcclxuICAgICAgc3RhdGUuaW5Mb2JieSA9IGFjdGlvbi5wYXlsb2FkXHJcbiAgICB9LFxyXG5cclxuICAgIG1vdmVDYXJkKFxyXG4gICAgICBzdGF0ZSxcclxuICAgICAgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPHtcclxuICAgICAgICBuZXh0UGxheWVyOiBudW1iZXJcclxuICAgICAgICBjYXJkPzogQ2FyZFxyXG4gICAgICAgIGRyYXc/OiBudW1iZXJcclxuICAgICAgICBjYXJkc1RvRHJhdz86IENhcmRbXVxyXG4gICAgICB9PlxyXG4gICAgKSB7XHJcbiAgICAgIGxldCB7IG5leHRQbGF5ZXIsIGNhcmQsIGNhcmRzVG9EcmF3ID0gW10sIGRyYXcgfSA9IGFjdGlvbi5wYXlsb2FkXHJcblxyXG4gICAgICBjb25zdCBjdXJQbGF5ZXJPYmogPSBzdGF0ZS5wbGF5ZXJzW3N0YXRlLmN1cnJlbnRQbGF5ZXJdXHJcblxyXG4gICAgICBuZXh0UGxheWVyID0gd3JhcE1vZChcclxuICAgICAgICBuZXh0UGxheWVyIC0gc3RhdGUub3JkZXJPZmZzZXQsXHJcbiAgICAgICAgc3RhdGUucGxheWVycy5sZW5ndGhcclxuICAgICAgKVxyXG5cclxuICAgICAgaWYgKGNhcmQ/LmFjdGlvbiA9PT0gJ3JldmVyc2UnKSBzdGF0ZS5kaXJlY3Rpb24gKj0gLTFcclxuXHJcbiAgICAgIGlmIChkcmF3KSB7XHJcbiAgICAgICAgc3RhdGUucGxheWVycyA9IHN0YXRlLnBsYXllcnMubWFwKChwKSA9PiB7XHJcbiAgICAgICAgICBpZiAocC5pZCA9PT0gY3VyUGxheWVyT2JqLmlkKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdDYXJkcyA9IHN0YXRlLmRyYXdpbmdTdGFjay5zbGljZSgwLCBkcmF3KVxyXG4gICAgICAgICAgICBpZiAoY3VyUGxheWVyT2JqLmlkID09PSBzdGF0ZS5wbGF5ZXJJZCAmJiBjYXJkc1RvRHJhdykge1xyXG4gICAgICAgICAgICAgIG5ld0NhcmRzID0gbmV3Q2FyZHMubWFwKChjLCBpZHgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAuLi5jLFxyXG4gICAgICAgICAgICAgICAgLi4uY2FyZHNUb0RyYXdbaWR4XSxcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uWTogMCxcclxuICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgICAgY2FyZHM6IHAuY2FyZHMuY29uY2F0KG5ld0NhcmRzKSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHBcclxuICAgICAgICB9KVxyXG4gICAgICAgIHN0YXRlLmRyYXdpbmdTdGFjayA9IHN0YXRlLmRyYXdpbmdTdGFja1xyXG4gICAgICAgICAgLnNsaWNlKGRyYXcpXHJcbiAgICAgICAgICAuY29uY2F0KGdlbmVyYXRlRHJhd2luZ0NhcmRzKGRyYXcpKVxyXG4gICAgICAgIHN0YXRlLmxhc3RQbGF5ZXJEcmF3ZWQgPSB0cnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjYXJkKSB7XHJcbiAgICAgICAgbGV0IGxheW91dElkOiBzdHJpbmcgfCB1bmRlZmluZWQgPSAnJ1xyXG4gICAgICAgIGxldCBzaG91bGRGbGlwID0gZmFsc2VcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgcGxheWVyIGFjdHVhbGx5IGhhcyB0aGUgY2FyZCAob3IgYW55IGNhcmQgaWYgbm90IGxvY2FsIHBsYXllcilcclxuICAgICAgICBjb25zdCBoYXNDYXJkID0gY3VyUGxheWVyT2JqLmNhcmRzLnNvbWUoYyA9PiBjdXJQbGF5ZXJPYmouaWQgPT09IHN0YXRlLnBsYXllcklkID8gYy5pZCA9PT0gY2FyZD8uaWQgOiB0cnVlKVxyXG5cclxuICAgICAgICBpZiAoaGFzQ2FyZCAmJiBjdXJQbGF5ZXJPYmouY2FyZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgaWYgKGN1clBsYXllck9iai5pZCAhPT0gc3RhdGUucGxheWVySWQpIHtcclxuICAgICAgICAgICAgbGF5b3V0SWQgPVxyXG4gICAgICAgICAgICAgIGN1clBsYXllck9iai5jYXJkc1tcclxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGN1clBsYXllck9iai5jYXJkcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgXS5sYXlvdXRJZFxyXG4gICAgICAgICAgICBzaG91bGRGbGlwID0gdHJ1ZVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGF5b3V0SWQgPSBjdXJQbGF5ZXJPYmouY2FyZHMuZmluZCgoYykgPT4gYy5pZCA9PT0gY2FyZD8uaWQpPy5sYXlvdXRJZFxyXG4gICAgICAgICAgICBjb25zdCBjYXJkVG9Nb3ZlID0gY3VyUGxheWVyT2JqLmNhcmRzLmZpbHRlcihcclxuICAgICAgICAgICAgICAoYykgPT4gYy5sYXlvdXRJZCA9PT0gbGF5b3V0SWRcclxuICAgICAgICAgICAgKVswXVxyXG5cclxuICAgICAgICAgICAgaWYgKGNhcmRUb01vdmUpIHtcclxuICAgICAgICAgICAgICBjYXJkLmNvbG9yID0gY2FyZFRvTW92ZS5jb2xvclxyXG4gICAgICAgICAgICAgIGNhcmQuYWN0aW9uID0gY2FyZFRvTW92ZS5hY3Rpb25cclxuICAgICAgICAgICAgICBjYXJkLmRpZ2l0ID0gY2FyZFRvTW92ZS5kaWdpdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIENhcmQgbm90IGluIGhhbmQgKGUuZy4gZmlyc3QgY2FyZCBwbGF5ZWQgYnkgc3lzdGVtKVxyXG4gICAgICAgICAgLy8gQW5pbWF0ZSBmcm9tIGRyYXdpbmcgc3RhY2sgKGRlY2spXHJcbiAgICAgICAgICBsYXlvdXRJZCA9IGBzeXN0ZW1fbW92ZV8ke2NhcmRMYXlvdXRJZElkeCsrfWBcclxuICAgICAgICAgIHNob3VsZEZsaXAgPSB0cnVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0ZS50YWJsZVN0YWNrID0gW1xyXG4gICAgICAgICAgLi4uc3RhdGUudGFibGVTdGFjay5zbGljZSgtMSksXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGxheW91dElkOiBsYXlvdXRJZCB8fCBgdW5rbm93bl8ke2NhcmRMYXlvdXRJZElkeCsrfWAsXHJcbiAgICAgICAgICAgIGNvbG9yOiBjYXJkLmNvbG9yLFxyXG4gICAgICAgICAgICBhY3Rpb246IGNhcmQuYWN0aW9uLFxyXG4gICAgICAgICAgICBkaWdpdDogY2FyZC5kaWdpdCxcclxuICAgICAgICAgICAgZmxpcDogc2hvdWxkRmxpcCxcclxuICAgICAgICAgICAgcm90YXRpb25ZOiAwLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdXHJcblxyXG4gICAgICAgIC8vIE9ubHkgcmVtb3ZlIGNhcmQgaWYgaXQgd2FzIGluIGhhbmRcclxuICAgICAgICBpZiAoaGFzQ2FyZCkge1xyXG4gICAgICAgICAgc3RhdGUucGxheWVycyA9IHN0YXRlLnBsYXllcnMubWFwKChwKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwID09PSBjdXJQbGF5ZXJPYmopIHtcclxuICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICAgIGNhcmRzOiBwLmNhcmRzLmZpbHRlcigoYykgPT4gYy5sYXlvdXRJZCAhPT0gbGF5b3V0SWQpLFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUubGFzdFBsYXllckRyYXdlZCA9IGZhbHNlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0YXRlLm5leHRQbGF5cmUgPSBuZXh0UGxheWVyXHJcbiAgICB9LFxyXG4gICAgbW92ZVBsYXllcihzdGF0ZSkge1xyXG4gICAgICBzdGF0ZS5wbGF5ZXJzID0gc3RhdGUucGxheWVycy5tYXAoKHApID0+IHtcclxuICAgICAgICBpZiAocC5pZCA9PT0gc3RhdGUucGxheWVySWQpIHtcclxuICAgICAgICAgIGNvbnN0IG15VHVybiA9IHN0YXRlLm5leHRQbGF5cmUgPT09IDBcclxuXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5wLFxyXG4gICAgICAgICAgICBjYXJkczogcC5jYXJkcy5tYXAoKGMpID0+IHtcclxuICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4uYyxcclxuICAgICAgICAgICAgICAgIHBsYXlhYmxlOlxyXG4gICAgICAgICAgICAgICAgICBteVR1cm4gJiZcclxuICAgICAgICAgICAgICAgICAgY2FuUGxheUNhcmQoXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudGFibGVTdGFja1tzdGF0ZS50YWJsZVN0YWNrLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGMsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubGFzdFBsYXllckRyYXdlZFxyXG4gICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwXHJcbiAgICAgIH0pXHJcbiAgICAgIHN0YXRlLmN1cnJlbnRQbGF5ZXIgPSBzdGF0ZS5uZXh0UGxheXJlXHJcbiAgICB9LFxyXG4gIH0sXHJcbn0pXHJcblxyXG5leHBvcnQgY29uc3Qge1xyXG4gIGluaXQsXHJcbiAgcmVhZHksXHJcbiAgc3RvcEdhbWUsXHJcbiAgbW92ZUNhcmQsXHJcbiAgbW92ZVBsYXllcixcclxuICBzZXRJbkxvYmJ5LFxyXG4gIHNldFBsYXllcklkLFxyXG59ID0gZ2FtZVNsaWNlLmFjdGlvbnNcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdhbWVTbGljZS5yZWR1Y2VyXHJcblxyXG4iXSwibmFtZXMiOlsiY3JlYXRlU2xpY2UiLCJjYW5QbGF5Q2FyZCIsIndyYXBNb2QiLCJjYXJkTGF5b3V0SWRJZHgiLCJnZW5lcmF0ZURyYXdpbmdDYXJkcyIsImNudCIsIkFycmF5IiwiZmlsbCIsIm1hcCIsImxheW91dElkIiwiaW5pdGlhbFN0YXRlIiwicGxheWVySWQiLCJjdXJyZW50UGxheWVyIiwibmV4dFBsYXlyZSIsIm9yZGVyT2Zmc2V0IiwiZGlyZWN0aW9uIiwidGFibGVTdGFjayIsImRyYXdpbmdTdGFjayIsInBsYXllcnMiLCJsYXN0UGxheWVyRHJhd2VkIiwiaW5HYW1lIiwiaW5Mb2JieSIsImdhbWVTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsInNldFBsYXllcklkIiwic3RhdGUiLCJhY3Rpb24iLCJwYXlsb2FkIiwiaW5pdCIsImNhcmRzIiwic3RhcnRpbmdDYXJkcyIsImZpcnN0Q2FyZCIsInJvdGF0aW9uWSIsInBsYXllcnNGaW5hbCIsIm15SWR4IiwibGVuZ3RoIiwiaWQiLCJpIiwicHVzaCIsImNhcmRzVG9EaXN0cmlidXRlIiwiYyIsInBsYXlhYmxlIiwiZm9yUGxheWVyIiwiY29uY2F0IiwicmVhZHkiLCJwbGF5ZXIiLCJpZHgiLCJmaWx0ZXIiLCJzdG9wR2FtZSIsInNldEluTG9iYnkiLCJtb3ZlQ2FyZCIsIm5leHRQbGF5ZXIiLCJjYXJkIiwiY2FyZHNUb0RyYXciLCJkcmF3IiwiY3VyUGxheWVyT2JqIiwicCIsIm5ld0NhcmRzIiwic2xpY2UiLCJzaG91bGRGbGlwIiwiaGFzQ2FyZCIsInNvbWUiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJmaW5kIiwiY2FyZFRvTW92ZSIsImNvbG9yIiwiZGlnaXQiLCJmbGlwIiwibW92ZVBsYXllciIsIm15VHVybiIsImFjdGlvbnMiLCJyZWR1Y2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./stores/features/gameSlice.ts\n"));

/***/ })

});