"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/main-menu/page",{

/***/ "(app-pages-browser)/./bots-server/BotsServer.ts":
/*!***********************************!*\
  !*** ./bots-server/BotsServer.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canPlayCard: function() { return /* binding */ canPlayCard; },\n/* harmony export */   \"default\": function() { return /* binding */ BotsServer; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventsObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventsObject */ \"(app-pages-browser)/./utils/EventsObject.ts\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/helpers */ \"(app-pages-browser)/./utils/helpers.ts\");\n/* harmony import */ var _data_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data.json */ \"(app-pages-browser)/./bots-server/data.json\");\n\n\n\nclass BotsServer extends _utils_EventsObject__WEBPACK_IMPORTED_MODULE_0__.EventsObject {\n    init() {\n        this.players = [];\n        this.curPlayer = 0;\n        this.direction = 1;\n        this.tableStk = [];\n        this.drawingStk = [];\n        this.sumDrawing = 0;\n        this.playersFinished = [];\n        this.lastPlayerDrew = false;\n        this.gameRunning = false;\n    }\n    joinPlayer(player) {\n        const playerId = this.players.length.toString();\n        this.players.push({\n            ...player,\n            id: playerId,\n            cards: []\n        });\n        return playerId;\n    }\n    addBots() {\n        const numToAdd = this.numberOfPlayers - this.players.length;\n        for(let i = 0; i < numToAdd; i++){\n            const bot = _data_json__WEBPACK_IMPORTED_MODULE_2__.players[i];\n            const playerId = this.players.length.toString();\n            this.players.push({\n                ...bot,\n                id: playerId,\n                cards: [],\n                isBot: true\n            });\n        }\n        this.fireEvent(\"players-changed\", this.players);\n        if (this.players.length === this.numberOfPlayers) setTimeout(()=>{\n            this.start();\n        }, 1000);\n    }\n    start() {\n        var _remainingCards_firstCardIndex, _remainingCards_firstCardIndex1, _this_players_find;\n        const cards = [\n            ..._data_json__WEBPACK_IMPORTED_MODULE_2__.cards\n        ];\n        (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.shuffle)(cards);\n        (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.shuffle)(this.players);\n        const NUM_CARDS = 7;\n        this.players.forEach((player, idx)=>{\n            player.cards = cards.slice(idx * NUM_CARDS, (idx + 1) * NUM_CARDS);\n        });\n        // Place remaining cards in drawing stack\n        const remainingCards = cards.slice(this.players.length * NUM_CARDS);\n        // Take first card from drawing stack and place it on table\n        // Make sure it's not a wild card to start with\n        let firstCardIndex = 0;\n        while(((_remainingCards_firstCardIndex = remainingCards[firstCardIndex]) === null || _remainingCards_firstCardIndex === void 0 ? void 0 : _remainingCards_firstCardIndex.action) === \"wild\" || ((_remainingCards_firstCardIndex1 = remainingCards[firstCardIndex]) === null || _remainingCards_firstCardIndex1 === void 0 ? void 0 : _remainingCards_firstCardIndex1.action) === \"draw four\"){\n            firstCardIndex++;\n        }\n        this.tableStk = [\n            remainingCards[firstCardIndex]\n        ];\n        this.drawingStk = [\n            ...remainingCards.slice(0, firstCardIndex),\n            ...remainingCards.slice(firstCardIndex + 1)\n        ];\n        this.fireEvent(\"game-init\", {\n            cards: ((_this_players_find = this.players.find((p)=>!p.isBot)) === null || _this_players_find === void 0 ? void 0 : _this_players_find.cards) || [],\n            players: this.players.map((p)=>({\n                    ...p,\n                    cards: []\n                }))\n        });\n        console.log(\"Game initialized, waiting to play first card:\", this.tableStk[0]);\n    }\n    ready() {\n        var _this_players_this_curPlayer, _this_players_this_curPlayer1;\n        console.log(\"Ready called, current player:\", this.curPlayer, \"is bot:\", (_this_players_this_curPlayer = this.players[this.curPlayer]) === null || _this_players_this_curPlayer === void 0 ? void 0 : _this_players_this_curPlayer.isBot);\n        if (!this.tableStk.length && this.drawingStk.length) {\n            const firstCard = this.drawingStk.shift();\n            this.tableStk.unshift(firstCard);\n            this.curPlayer = this.players.length - 1;\n            this.move(false, firstCard.id);\n            return;\n        }\n        if ((_this_players_this_curPlayer1 = this.players[this.curPlayer]) === null || _this_players_this_curPlayer1 === void 0 ? void 0 : _this_players_this_curPlayer1.isBot) this.moveBot();\n    }\n    move(draw, cardId) {\n        if (this.botTimeout) {\n            clearTimeout(this.botTimeout);\n            this.botTimeout = null;\n        }\n        let moveEventObj = {\n            nxtPlayer: 0,\n            curPlayer: 0\n        };\n        let card;\n        if (cardId) card = getCardById(cardId);\n        console.log(\"Move request:\", {\n            draw,\n            cardId,\n            card,\n            curPlayer: this.curPlayer\n        });\n        if (card && !canPlayCard(this.tableStk[0], card, this.lastPlayerDrew)) {\n            console.log(\"Move rejected: cannot play card\", {\n                tableCard: this.tableStk[0],\n                card\n            });\n            return false;\n        }\n        if (draw) {\n            let drawCnt = 1;\n            if (this.sumDrawing) {\n                drawCnt = this.sumDrawing;\n                this.sumDrawing = 0;\n            }\n            moveEventObj.draw = drawCnt;\n            if (drawCnt + 1 > this.drawingStk.length) {\n                this.drawingStk = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.shuffle)(this.tableStk.slice(5, this.tableStk.length));\n                this.tableStk = this.tableStk.slice(0, 5);\n            }\n            moveEventObj.cardsToDraw = this.drawingStk.slice(0, drawCnt);\n            this.players[this.curPlayer].cards = this.drawingStk.slice(0, drawCnt).concat(this.players[this.curPlayer].cards);\n            this.drawingStk = this.drawingStk.slice(drawCnt, this.drawingStk.length);\n            this.lastPlayerDrew = true;\n        }\n        let nxtPlayer = this.getNextPlayer(card);\n        moveEventObj.curPlayer = this.curPlayer;\n        moveEventObj.nxtPlayer = nxtPlayer;\n        if (card) {\n            if (card.action === \"draw two\") this.sumDrawing += 2;\n            if (card.action === \"draw four\") this.sumDrawing += 4;\n            this.tableStk.unshift(card);\n            moveEventObj.card = card;\n            // Only try to remove card from player if they have it (system might play first card)\n            const hasCard = this.players[this.curPlayer].cards.some((c)=>c.id === (card === null || card === void 0 ? void 0 : card.id));\n            if (hasCard) {\n                this.players[this.curPlayer].cards = this.players[this.curPlayer].cards.filter((c)=>c.id !== (card === null || card === void 0 ? void 0 : card.id));\n            }\n            this.lastPlayerDrew = false;\n            // Check if game finished\n            if (this.players[this.curPlayer].cards.length === 0) this.playersFinished.push(this.curPlayer);\n            if (this.playersFinished.length === this.players.length - 1) {\n                this.playersFinished.push(nxtPlayer);\n                this.finishGame();\n                this.fireEvent(\"move\", moveEventObj);\n                return;\n            }\n        }\n        this.curPlayer = nxtPlayer;\n        this.fireEvent(\"move\", moveEventObj);\n        if (this.players[this.curPlayer].isBot) this.moveBot();\n    }\n    getNextPlayer(card) {\n        var _this = this;\n        let nxtPlayer = this.curPlayer;\n        if ((card === null || card === void 0 ? void 0 : card.action) === \"reverse\") this.direction *= -1;\n        const moveForward = function() {\n            let steps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;\n            while(steps--){\n                nxtPlayer = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.wrapMod)(nxtPlayer + 1 * _this.direction, _this.players.length);\n                while(_this.players[nxtPlayer].cards.length === 0)nxtPlayer = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.wrapMod)(nxtPlayer + 1 * _this.direction, _this.players.length);\n            }\n        };\n        //Move to next player ( if not wild card )\n        if ((card === null || card === void 0 ? void 0 : card.action) === \"skip\") {\n            moveForward(2);\n        } else if ((card === null || card === void 0 ? void 0 : card.action) !== \"wild\") moveForward();\n        return nxtPlayer;\n    }\n    moveBot() {\n        if (this.botTimeout) {\n            clearTimeout(this.botTimeout);\n        }\n        this.botTimeout = setTimeout(()=>{\n            var _this_players_this_curPlayer;\n            if (!((_this_players_this_curPlayer = this.players[this.curPlayer]) === null || _this_players_this_curPlayer === void 0 ? void 0 : _this_players_this_curPlayer.isBot)) {\n                this.botTimeout = null;\n                return;\n            }\n            const validCards = this.players[this.curPlayer].cards.filter((card)=>canPlayCard(this.tableStk[0], card, this.lastPlayerDrew));\n            if (validCards.length > 0) {\n                this.botTimeout = null;\n                const randomCard = validCards[Math.floor(Math.random() * validCards.length)];\n                return this.move(false, randomCard.id);\n            }\n            this.botTimeout = null;\n            return this.move(true, null);\n        }, 1500);\n    }\n    finishGame() {\n        const playersFinishingOrder = this.playersFinished.map((idx)=>this.players[idx]);\n        this.init();\n        this.fireEvent(\"finish-game\", playersFinishingOrder);\n    }\n    constructor(numberOfPlayers = 4){\n        super();\n        this.players = [];\n        this.curPlayer = 0;\n        this.direction = 1;\n        this.tableStk = [];\n        this.drawingStk = [];\n        this.sumDrawing = 0;\n        this.lastPlayerDrew = false;\n        this.playersFinished = [];\n        this.gameRunning = false;\n        this.numberOfPlayers = 4;\n        this.botTimeout = null;\n        this.numberOfPlayers = numberOfPlayers;\n    }\n}\n\nfunction canPlayCard(oldCard, newCard, lastPlayerDrew) {\n    const isOldDawingCard = (oldCard === null || oldCard === void 0 ? void 0 : oldCard.action) && oldCard.action.indexOf(\"draw\") !== -1;\n    const haveToDraw = isOldDawingCard && !lastPlayerDrew;\n    const isNewDawingCard = (newCard === null || newCard === void 0 ? void 0 : newCard.action) && newCard.action.indexOf(\"draw\") !== -1;\n    //No Card Played Yet\n    if (!oldCard) return true;\n    if (!haveToDraw && newCard.action === \"wild\") return true;\n    if (newCard.action === \"draw four\") return true;\n    if (oldCard.color === \"black\" && !haveToDraw) return true;\n    if (haveToDraw && isNewDawingCard) return true;\n    if (!haveToDraw && oldCard.color === newCard.color) return true;\n    if (oldCard.digit !== undefined && oldCard.digit === newCard.digit) return true;\n    return false;\n}\nconst getCardById = (id)=>_data_json__WEBPACK_IMPORTED_MODULE_2__.cards.find((c)=>c.id === id);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2JvdHMtc2VydmVyL0JvdHNTZXJ2ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUQ7QUFDRDtBQUVwQjtBQWdCZixNQUFNSSxtQkFBbUJKLDZEQUFZQTtJQW1CbERLLE9BQU87UUFDTCxJQUFJLENBQUNDLE9BQU8sR0FBRyxFQUFFO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLGVBQWUsR0FBRyxFQUFFO1FBQ3pCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO0lBQ3JCO0lBRUFDLFdBQVdDLE1BQWMsRUFBRTtRQUN6QixNQUFNQyxXQUFXLElBQUksQ0FBQ1gsT0FBTyxDQUFDWSxNQUFNLENBQUNDLFFBQVE7UUFFN0MsSUFBSSxDQUFDYixPQUFPLENBQUNjLElBQUksQ0FBQztZQUNoQixHQUFHSixNQUFNO1lBQ1RLLElBQUlKO1lBQ0pLLE9BQU8sRUFBRTtRQUNYO1FBRUEsT0FBT0w7SUFDVDtJQUVBTSxVQUFVO1FBQ1IsTUFBTUMsV0FBVyxJQUFJLENBQUNDLGVBQWUsR0FBRyxJQUFJLENBQUNuQixPQUFPLENBQUNZLE1BQU07UUFDM0QsSUFBSyxJQUFJUSxJQUFJLEdBQUdBLElBQUlGLFVBQVVFLElBQUs7WUFDakMsTUFBTUMsTUFBTSwrQ0FBcUIsQ0FBQ0QsRUFBRTtZQUNwQyxNQUFNVCxXQUFXLElBQUksQ0FBQ1gsT0FBTyxDQUFDWSxNQUFNLENBQUNDLFFBQVE7WUFDN0MsSUFBSSxDQUFDYixPQUFPLENBQUNjLElBQUksQ0FBQztnQkFDaEIsR0FBR08sR0FBRztnQkFDTk4sSUFBSUo7Z0JBQ0pLLE9BQU8sRUFBRTtnQkFDVE0s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LGNBQWNDLGlCQUFpQixPQUFPO0lBRTFDLElBQUksQ0FBQ0QsY0FBY0osUUFBUU0sS0FBSyxLQUFLTCxRQUFRSyxLQUFLLEVBQUUsT0FBTztJQUUzRCxJQUFJTixRQUFRTyxLQUFLLEtBQUtDLGFBQWFSLFFBQVFPLEtBQUssS0FBS04sUUFBUU0sS0FBSyxFQUNoRSxPQUFPO0lBRVQsT0FBTztBQUNUO0FBRUEsTUFBTTVCLGNBQWMsQ0FBQ3BDLEtBQ25CLDZDQUFtQixDQUFDa0IsSUFBSSxDQUFDLENBQUMyQixJQUFZQSxFQUFFN0MsRUFBRSxLQUFLQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ib3RzLXNlcnZlci9Cb3RzU2VydmVyLnRzPzk3OTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRzT2JqZWN0IH0gZnJvbSAnQC91dGlscy9FdmVudHNPYmplY3QnXHJcbmltcG9ydCB7IHNodWZmbGUsIHdyYXBNb2QgfSBmcm9tICdAL3V0aWxzL2hlbHBlcnMnXHJcbmltcG9ydCB7IENhcmQsIFBsYXllciB9IGZyb20gJ0AvdXRpbHMvaW50ZXJmYWNlcydcclxuaW1wb3J0IGRhdGEgZnJvbSAnLi9kYXRhLmpzb24nXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElNb3ZlRXZlbnQge1xyXG4gIGN1clBsYXllcjogbnVtYmVyXHJcbiAgbnh0UGxheWVyOiBudW1iZXJcclxuICBjYXJkPzogQ2FyZFxyXG4gIGRyYXc/OiBudW1iZXJcclxuICBjYXJkc1RvRHJhdz86IENhcmRbXVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElTdGFydEV2ZW50IHtcclxuICBjYXJkczogQ2FyZFtdXHJcbiAgcGxheWVyczogUGxheWVyW11cclxuICBwbGF5ZXJJZDogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvdHNTZXJ2ZXIgZXh0ZW5kcyBFdmVudHNPYmplY3Qge1xyXG4gIHBsYXllcnM6IFBsYXllcltdID0gW11cclxuICBjdXJQbGF5ZXIgPSAwXHJcbiAgZGlyZWN0aW9uID0gMVxyXG4gIHRhYmxlU3RrOiBDYXJkW10gPSBbXVxyXG4gIGRyYXdpbmdTdGs6IENhcmRbXSA9IFtdXHJcbiAgc3VtRHJhd2luZyA9IDBcclxuICBsYXN0UGxheWVyRHJldyA9IGZhbHNlXHJcbiAgcGxheWVyc0ZpbmlzaGVkOiBudW1iZXJbXSA9IFtdXHJcbiAgZ2FtZVJ1bm5pbmcgPSBmYWxzZVxyXG4gIG51bWJlck9mUGxheWVycyA9IDRcclxuXHJcbiAgYm90VGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbFxyXG5cclxuICBjb25zdHJ1Y3RvcihudW1iZXJPZlBsYXllcnMgPSA0KSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICB0aGlzLm51bWJlck9mUGxheWVycyA9IG51bWJlck9mUGxheWVyc1xyXG4gIH1cclxuXHJcbiAgaW5pdCgpIHtcclxuICAgIHRoaXMucGxheWVycyA9IFtdXHJcbiAgICB0aGlzLmN1clBsYXllciA9IDBcclxuICAgIHRoaXMuZGlyZWN0aW9uID0gMVxyXG4gICAgdGhpcy50YWJsZVN0ayA9IFtdXHJcbiAgICB0aGlzLmRyYXdpbmdTdGsgPSBbXVxyXG4gICAgdGhpcy5zdW1EcmF3aW5nID0gMFxyXG4gICAgdGhpcy5wbGF5ZXJzRmluaXNoZWQgPSBbXVxyXG4gICAgdGhpcy5sYXN0UGxheWVyRHJldyA9IGZhbHNlXHJcbiAgICB0aGlzLmdhbWVSdW5uaW5nID0gZmFsc2VcclxuICB9XHJcblxyXG4gIGpvaW5QbGF5ZXIocGxheWVyOiBQbGF5ZXIpIHtcclxuICAgIGNvbnN0IHBsYXllcklkID0gdGhpcy5wbGF5ZXJzLmxlbmd0aC50b1N0cmluZygpXHJcblxyXG4gICAgdGhpcy5wbGF5ZXJzLnB1c2goe1xyXG4gICAgICAuLi5wbGF5ZXIsXHJcbiAgICAgIGlkOiBwbGF5ZXJJZCxcclxuICAgICAgY2FyZHM6IFtdLFxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gcGxheWVySWRcclxuICB9XHJcblxyXG4gIGFkZEJvdHMoKSB7XHJcbiAgICBjb25zdCBudW1Ub0FkZCA9IHRoaXMubnVtYmVyT2ZQbGF5ZXJzIC0gdGhpcy5wbGF5ZXJzLmxlbmd0aFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Ub0FkZDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGJvdCA9IChkYXRhIGFzIGFueSkucGxheWVyc1tpXVxyXG4gICAgICBjb25zdCBwbGF5ZXJJZCA9IHRoaXMucGxheWVycy5sZW5ndGgudG9TdHJpbmcoKVxyXG4gICAgICB0aGlzLnBsYXllcnMucHVzaCh7XHJcbiAgICAgICAgLi4uYm90LFxyXG4gICAgICAgIGlkOiBwbGF5ZXJJZCxcclxuICAgICAgICBjYXJkczogW10sXHJcbiAgICAgICAgaXNCb3Q6IHRydWUsXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgICB0aGlzLmZpcmVFdmVudCgncGxheWVycy1jaGFuZ2VkJywgdGhpcy5wbGF5ZXJzKVxyXG4gICAgaWYgKHRoaXMucGxheWVycy5sZW5ndGggPT09IHRoaXMubnVtYmVyT2ZQbGF5ZXJzKVxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLnN0YXJ0KClcclxuICAgICAgfSwgMTAwMClcclxuICB9XHJcblxyXG4gIHN0YXJ0KCkge1xyXG4gICAgY29uc3QgY2FyZHMgPSBbLi4uKGRhdGEgYXMgYW55KS5jYXJkc10gYXMgQ2FyZFtdXHJcbiAgICBzaHVmZmxlKGNhcmRzKVxyXG4gICAgc2h1ZmZsZSh0aGlzLnBsYXllcnMpXHJcbiAgICBjb25zdCBOVU1fQ0FSRFMgPSA3XHJcbiAgICB0aGlzLnBsYXllcnMuZm9yRWFjaCgocGxheWVyLCBpZHgpID0+IHtcclxuICAgICAgcGxheWVyLmNhcmRzID0gY2FyZHMuc2xpY2UoaWR4ICogTlVNX0NBUkRTLCAoaWR4ICsgMSkgKiBOVU1fQ0FSRFMpXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIFBsYWNlIHJlbWFpbmluZyBjYXJkcyBpbiBkcmF3aW5nIHN0YWNrXHJcbiAgICBjb25zdCByZW1haW5pbmdDYXJkcyA9IGNhcmRzLnNsaWNlKHRoaXMucGxheWVycy5sZW5ndGggKiBOVU1fQ0FSRFMpXHJcblxyXG4gICAgLy8gVGFrZSBmaXJzdCBjYXJkIGZyb20gZHJhd2luZyBzdGFjayBhbmQgcGxhY2UgaXQgb24gdGFibGVcclxuICAgIC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIHdpbGQgY2FyZCB0byBzdGFydCB3aXRoXHJcbiAgICBsZXQgZmlyc3RDYXJkSW5kZXggPSAwXHJcbiAgICB3aGlsZSAocmVtYWluaW5nQ2FyZHNbZmlyc3RDYXJkSW5kZXhdPy5hY3Rpb24gPT09ICd3aWxkJyB8fFxyXG4gICAgICByZW1haW5pbmdDYXJkc1tmaXJzdENhcmRJbmRleF0/LmFjdGlvbiA9PT0gJ2RyYXcgZm91cicpIHtcclxuICAgICAgZmlyc3RDYXJkSW5kZXgrK1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGFibGVTdGsgPSBbcmVtYWluaW5nQ2FyZHNbZmlyc3RDYXJkSW5kZXhdXVxyXG4gICAgdGhpcy5kcmF3aW5nU3RrID0gW1xyXG4gICAgICAuLi5yZW1haW5pbmdDYXJkcy5zbGljZSgwLCBmaXJzdENhcmRJbmRleCksXHJcbiAgICAgIC4uLnJlbWFpbmluZ0NhcmRzLnNsaWNlKGZpcnN0Q2FyZEluZGV4ICsgMSlcclxuICAgIF1cclxuXHJcbiAgICB0aGlzLmZpcmVFdmVudCgnZ2FtZS1pbml0Jywge1xyXG4gICAgICBjYXJkczogdGhpcy5wbGF5ZXJzLmZpbmQoKHApID0+ICFwLmlzQm90KT8uY2FyZHMgfHwgW10sXHJcbiAgICAgIHBsYXllcnM6IHRoaXMucGxheWVycy5tYXAoKHApID0+ICh7IC4uLnAsIGNhcmRzOiBbXSB9KSksXHJcbiAgICB9KVxyXG5cclxuICAgIGNvbnNvbGUubG9nKCdHYW1lIGluaXRpYWxpemVkLCB3YWl0aW5nIHRvIHBsYXkgZmlyc3QgY2FyZDonLCB0aGlzLnRhYmxlU3RrWzBdKVxyXG4gIH1cclxuXHJcbiAgcmVhZHkoKSB7XHJcbiAgICBjb25zb2xlLmxvZygnUmVhZHkgY2FsbGVkLCBjdXJyZW50IHBsYXllcjonLCB0aGlzLmN1clBsYXllciwgJ2lzIGJvdDonLCB0aGlzLnBsYXllcnNbdGhpcy5jdXJQbGF5ZXJdPy5pc0JvdClcclxuICAgIGlmICghdGhpcy50YWJsZVN0ay5sZW5ndGggJiYgdGhpcy5kcmF3aW5nU3RrLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBmaXJzdENhcmQgPSB0aGlzLmRyYXdpbmdTdGsuc2hpZnQoKSBhcyBDYXJkXHJcbiAgICAgIHRoaXMudGFibGVTdGsudW5zaGlmdChmaXJzdENhcmQpXHJcbiAgICAgIHRoaXMuY3VyUGxheWVyID0gdGhpcy5wbGF5ZXJzLmxlbmd0aCAtIDFcclxuICAgICAgdGhpcy5tb3ZlKGZhbHNlLCBmaXJzdENhcmQuaWQgYXMgc3RyaW5nKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGlmICh0aGlzLnBsYXllcnNbdGhpcy5jdXJQbGF5ZXJdPy5pc0JvdCkgdGhpcy5tb3ZlQm90KClcclxuICB9XHJcblxyXG4gIG1vdmUoZHJhdzogYm9vbGVhbiB8IG51bGwsIGNhcmRJZDogc3RyaW5nIHwgbnVsbCkge1xyXG4gICAgaWYgKHRoaXMuYm90VGltZW91dCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5ib3RUaW1lb3V0KVxyXG4gICAgICB0aGlzLmJvdFRpbWVvdXQgPSBudWxsXHJcbiAgICB9XHJcbiAgICBsZXQgbW92ZUV2ZW50T2JqOiBJTW92ZUV2ZW50ID0geyBueHRQbGF5ZXI6IDAsIGN1clBsYXllcjogMCB9XHJcbiAgICBsZXQgY2FyZDogQ2FyZCB8IHVuZGVmaW5lZFxyXG5cclxuICAgIGlmIChjYXJkSWQpIGNhcmQgPSBnZXRDYXJkQnlJZChjYXJkSWQpIGFzIENhcmRcclxuXHJcbiAgICBjb25zb2xlLmxvZygnTW92ZSByZXF1ZXN0OicsIHsgZHJhdywgY2FyZElkLCBjYXJkLCBjdXJQbGF5ZXI6IHRoaXMuY3VyUGxheWVyIH0pXHJcblxyXG4gICAgaWYgKGNhcmQgJiYgIWNhblBsYXlDYXJkKHRoaXMudGFibGVTdGtbMF0sIGNhcmQsIHRoaXMubGFzdFBsYXllckRyZXcpKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdNb3ZlIHJlamVjdGVkOiBjYW5ub3QgcGxheSBjYXJkJywgeyB0YWJsZUNhcmQ6IHRoaXMudGFibGVTdGtbMF0sIGNhcmQgfSlcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRyYXcpIHtcclxuICAgICAgbGV0IGRyYXdDbnQgPSAxXHJcbiAgICAgIGlmICh0aGlzLnN1bURyYXdpbmcpIHtcclxuICAgICAgICBkcmF3Q250ID0gdGhpcy5zdW1EcmF3aW5nXHJcbiAgICAgICAgdGhpcy5zdW1EcmF3aW5nID0gMFxyXG4gICAgICB9XHJcblxyXG4gICAgICBtb3ZlRXZlbnRPYmouZHJhdyA9IGRyYXdDbnRcclxuICAgICAgaWYgKGRyYXdDbnQgKyAxID4gdGhpcy5kcmF3aW5nU3RrLmxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuZHJhd2luZ1N0ayA9IHNodWZmbGUoXHJcbiAgICAgICAgICB0aGlzLnRhYmxlU3RrLnNsaWNlKDUsIHRoaXMudGFibGVTdGsubGVuZ3RoKVxyXG4gICAgICAgICkgYXMgQ2FyZFtdXHJcbiAgICAgICAgdGhpcy50YWJsZVN0ayA9IHRoaXMudGFibGVTdGsuc2xpY2UoMCwgNSlcclxuICAgICAgfVxyXG5cclxuICAgICAgbW92ZUV2ZW50T2JqLmNhcmRzVG9EcmF3ID0gdGhpcy5kcmF3aW5nU3RrLnNsaWNlKDAsIGRyYXdDbnQpXHJcbiAgICAgIHRoaXMucGxheWVyc1t0aGlzLmN1clBsYXllcl0uY2FyZHMgPSB0aGlzLmRyYXdpbmdTdGtcclxuICAgICAgICAuc2xpY2UoMCwgZHJhd0NudClcclxuICAgICAgICAuY29uY2F0KHRoaXMucGxheWVyc1t0aGlzLmN1clBsYXllcl0uY2FyZHMpXHJcblxyXG4gICAgICB0aGlzLmRyYXdpbmdTdGsgPSB0aGlzLmRyYXdpbmdTdGsuc2xpY2UoZHJhd0NudCwgdGhpcy5kcmF3aW5nU3RrLmxlbmd0aClcclxuICAgICAgdGhpcy5sYXN0UGxheWVyRHJldyA9IHRydWVcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbnh0UGxheWVyID0gdGhpcy5nZXROZXh0UGxheWVyKGNhcmQpXHJcblxyXG4gICAgbW92ZUV2ZW50T2JqLmN1clBsYXllciA9IHRoaXMuY3VyUGxheWVyXHJcbiAgICBtb3ZlRXZlbnRPYmoubnh0UGxheWVyID0gbnh0UGxheWVyXHJcblxyXG4gICAgaWYgKGNhcmQpIHtcclxuICAgICAgaWYgKGNhcmQuYWN0aW9uID09PSAnZHJhdyB0d28nKSB0aGlzLnN1bURyYXdpbmcgKz0gMlxyXG4gICAgICBpZiAoY2FyZC5hY3Rpb24gPT09ICdkcmF3IGZvdXInKSB0aGlzLnN1bURyYXdpbmcgKz0gNFxyXG5cclxuICAgICAgdGhpcy50YWJsZVN0ay51bnNoaWZ0KGNhcmQpXHJcbiAgICAgIG1vdmVFdmVudE9iai5jYXJkID0gY2FyZFxyXG5cclxuICAgICAgLy8gT25seSB0cnkgdG8gcmVtb3ZlIGNhcmQgZnJvbSBwbGF5ZXIgaWYgdGhleSBoYXZlIGl0IChzeXN0ZW0gbWlnaHQgcGxheSBmaXJzdCBjYXJkKVxyXG4gICAgICBjb25zdCBoYXNDYXJkID0gdGhpcy5wbGF5ZXJzW3RoaXMuY3VyUGxheWVyXS5jYXJkcy5zb21lKGMgPT4gYy5pZCA9PT0gY2FyZD8uaWQpXHJcbiAgICAgIGlmIChoYXNDYXJkKSB7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXJzW3RoaXMuY3VyUGxheWVyXS5jYXJkcyA9IHRoaXMucGxheWVyc1tcclxuICAgICAgICAgIHRoaXMuY3VyUGxheWVyXHJcbiAgICAgICAgXS5jYXJkcy5maWx0ZXIoKGMpID0+IGMuaWQgIT09IGNhcmQ/LmlkKVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubGFzdFBsYXllckRyZXcgPSBmYWxzZVxyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgZ2FtZSBmaW5pc2hlZFxyXG4gICAgICBpZiAodGhpcy5wbGF5ZXJzW3RoaXMuY3VyUGxheWVyXS5jYXJkcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgdGhpcy5wbGF5ZXJzRmluaXNoZWQucHVzaCh0aGlzLmN1clBsYXllcilcclxuICAgICAgaWYgKHRoaXMucGxheWVyc0ZpbmlzaGVkLmxlbmd0aCA9PT0gdGhpcy5wbGF5ZXJzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICB0aGlzLnBsYXllcnNGaW5pc2hlZC5wdXNoKG54dFBsYXllcilcclxuICAgICAgICB0aGlzLmZpbmlzaEdhbWUoKVxyXG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCdtb3ZlJywgbW92ZUV2ZW50T2JqIGFzIElNb3ZlRXZlbnQpXHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmN1clBsYXllciA9IG54dFBsYXllclxyXG5cclxuICAgIHRoaXMuZmlyZUV2ZW50KCdtb3ZlJywgbW92ZUV2ZW50T2JqIGFzIElNb3ZlRXZlbnQpXHJcblxyXG4gICAgaWYgKHRoaXMucGxheWVyc1t0aGlzLmN1clBsYXllcl0uaXNCb3QpIHRoaXMubW92ZUJvdCgpXHJcbiAgfVxyXG5cclxuICBnZXROZXh0UGxheWVyKGNhcmQ/OiBDYXJkKSB7XHJcbiAgICBsZXQgbnh0UGxheWVyID0gdGhpcy5jdXJQbGF5ZXJcclxuXHJcbiAgICBpZiAoY2FyZD8uYWN0aW9uID09PSAncmV2ZXJzZScpIHRoaXMuZGlyZWN0aW9uICo9IC0xXHJcblxyXG4gICAgY29uc3QgbW92ZUZvcndhcmQgPSAoc3RlcHM6IG51bWJlciA9IDEpID0+IHtcclxuICAgICAgd2hpbGUgKHN0ZXBzLS0pIHtcclxuICAgICAgICBueHRQbGF5ZXIgPSB3cmFwTW9kKFxyXG4gICAgICAgICAgbnh0UGxheWVyICsgMSAqIHRoaXMuZGlyZWN0aW9uLFxyXG4gICAgICAgICAgdGhpcy5wbGF5ZXJzLmxlbmd0aFxyXG4gICAgICAgIClcclxuICAgICAgICB3aGlsZSAodGhpcy5wbGF5ZXJzW254dFBsYXllcl0uY2FyZHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgbnh0UGxheWVyID0gd3JhcE1vZChcclxuICAgICAgICAgICAgbnh0UGxheWVyICsgMSAqIHRoaXMuZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICB0aGlzLnBsYXllcnMubGVuZ3RoXHJcbiAgICAgICAgICApXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL01vdmUgdG8gbmV4dCBwbGF5ZXIgKCBpZiBub3Qgd2lsZCBjYXJkIClcclxuICAgIGlmIChjYXJkPy5hY3Rpb24gPT09ICdza2lwJykge1xyXG4gICAgICBtb3ZlRm9yd2FyZCgyKVxyXG4gICAgfSBlbHNlIGlmIChjYXJkPy5hY3Rpb24gIT09ICd3aWxkJykgbW92ZUZvcndhcmQoKVxyXG5cclxuICAgIHJldHVybiBueHRQbGF5ZXJcclxuICB9XHJcblxyXG4gIG1vdmVCb3QoKSB7XHJcbiAgICBpZiAodGhpcy5ib3RUaW1lb3V0KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmJvdFRpbWVvdXQpXHJcbiAgICB9XHJcbiAgICB0aGlzLmJvdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLnBsYXllcnNbdGhpcy5jdXJQbGF5ZXJdPy5pc0JvdCkge1xyXG4gICAgICAgIHRoaXMuYm90VGltZW91dCA9IG51bGxcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgICBjb25zdCB2YWxpZENhcmRzID0gdGhpcy5wbGF5ZXJzW3RoaXMuY3VyUGxheWVyXS5jYXJkcy5maWx0ZXIoY2FyZCA9PlxyXG4gICAgICAgIGNhblBsYXlDYXJkKHRoaXMudGFibGVTdGtbMF0sIGNhcmQsIHRoaXMubGFzdFBsYXllckRyZXcpXHJcbiAgICAgIClcclxuXHJcbiAgICAgIGlmICh2YWxpZENhcmRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLmJvdFRpbWVvdXQgPSBudWxsXHJcbiAgICAgICAgY29uc3QgcmFuZG9tQ2FyZCA9IHZhbGlkQ2FyZHNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdmFsaWRDYXJkcy5sZW5ndGgpXVxyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdmUoZmFsc2UsIHJhbmRvbUNhcmQuaWQgYXMgc3RyaW5nKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmJvdFRpbWVvdXQgPSBudWxsXHJcbiAgICAgIHJldHVybiB0aGlzLm1vdmUodHJ1ZSwgbnVsbClcclxuICAgIH0sIDE1MDApXHJcbiAgfVxyXG5cclxuICBmaW5pc2hHYW1lKCkge1xyXG4gICAgY29uc3QgcGxheWVyc0ZpbmlzaGluZ09yZGVyID0gdGhpcy5wbGF5ZXJzRmluaXNoZWQubWFwKFxyXG4gICAgICAoaWR4KSA9PiB0aGlzLnBsYXllcnNbaWR4XVxyXG4gICAgKVxyXG5cclxuICAgIHRoaXMuaW5pdCgpXHJcbiAgICB0aGlzLmZpcmVFdmVudCgnZmluaXNoLWdhbWUnLCBwbGF5ZXJzRmluaXNoaW5nT3JkZXIpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FuUGxheUNhcmQoXHJcbiAgb2xkQ2FyZDogQ2FyZCxcclxuICBuZXdDYXJkOiBDYXJkLFxyXG4gIGxhc3RQbGF5ZXJEcmV3OiBib29sZWFuXHJcbikge1xyXG4gIGNvbnN0IGlzT2xkRGF3aW5nQ2FyZCA9XHJcbiAgICBvbGRDYXJkPy5hY3Rpb24gJiYgb2xkQ2FyZC5hY3Rpb24uaW5kZXhPZignZHJhdycpICE9PSAtMVxyXG4gIGNvbnN0IGhhdmVUb0RyYXcgPSBpc09sZERhd2luZ0NhcmQgJiYgIWxhc3RQbGF5ZXJEcmV3XHJcbiAgY29uc3QgaXNOZXdEYXdpbmdDYXJkID1cclxuICAgIG5ld0NhcmQ/LmFjdGlvbiAmJiBuZXdDYXJkLmFjdGlvbi5pbmRleE9mKCdkcmF3JykgIT09IC0xXHJcblxyXG4gIC8vTm8gQ2FyZCBQbGF5ZWQgWWV0XHJcbiAgaWYgKCFvbGRDYXJkKSByZXR1cm4gdHJ1ZVxyXG5cclxuICBpZiAoIWhhdmVUb0RyYXcgJiYgbmV3Q2FyZC5hY3Rpb24gPT09ICd3aWxkJykgcmV0dXJuIHRydWVcclxuXHJcbiAgaWYgKG5ld0NhcmQuYWN0aW9uID09PSAnZHJhdyBmb3VyJykgcmV0dXJuIHRydWVcclxuXHJcbiAgaWYgKG9sZENhcmQuY29sb3IgPT09ICdibGFjaycgJiYgIWhhdmVUb0RyYXcpIHJldHVybiB0cnVlXHJcblxyXG4gIGlmIChoYXZlVG9EcmF3ICYmIGlzTmV3RGF3aW5nQ2FyZCkgcmV0dXJuIHRydWVcclxuXHJcbiAgaWYgKCFoYXZlVG9EcmF3ICYmIG9sZENhcmQuY29sb3IgPT09IG5ld0NhcmQuY29sb3IpIHJldHVybiB0cnVlXHJcblxyXG4gIGlmIChvbGRDYXJkLmRpZ2l0ICE9PSB1bmRlZmluZWQgJiYgb2xkQ2FyZC5kaWdpdCA9PT0gbmV3Q2FyZC5kaWdpdClcclxuICAgIHJldHVybiB0cnVlXHJcblxyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG5jb25zdCBnZXRDYXJkQnlJZCA9IChpZDogc3RyaW5nKSA9PlxyXG4gIChkYXRhIGFzIGFueSkuY2FyZHMuZmluZCgoYzogQ2FyZCkgPT4gYy5pZCA9PT0gaWQpXHJcbiJdLCJuYW1lcyI6WyJFdmVudHNPYmplY3QiLCJzaHVmZmxlIiwid3JhcE1vZCIsImRhdGEiLCJCb3RzU2VydmVyIiwiaW5pdCIsInBsYXllcnMiLCJjdXJQbGF5ZXIiLCJkaXJlY3Rpb24iLCJ0YWJsZVN0ayIsImRyYXdpbmdTdGsiLCJzdW1EcmF3aW5nIiwicGxheWVyc0ZpbmlzaGVkIiwibGFzdFBsYXllckRyZXciLCJnYW1lUnVubmluZyIsImpvaW5QbGF5ZXIiLCJwbGF5ZXIiLCJwbGF5ZXJJZCIsImxlbmd0aCIsInRvU3RyaW5nIiwicHVzaCIsImlkIiwiY2FyZHMiLCJhZGRCb3RzIiwibnVtVG9BZGQiLCJudW1iZXJPZlBsYXllcnMiLCJpIiwiYm90IiwiaXNCb3QiLCJmaXJlRXZlbnQiLCJzZXRUaW1lb3V0Iiwic3RhcnQiLCJyZW1haW5pbmdDYXJkcyIsIk5VTV9DQVJEUyIsImZvckVhY2giLCJpZHgiLCJzbGljZSIsImZpcnN0Q2FyZEluZGV4IiwiYWN0aW9uIiwiZmluZCIsInAiLCJtYXAiLCJjb25zb2xlIiwibG9nIiwicmVhZHkiLCJmaXJzdENhcmQiLCJzaGlmdCIsInVuc2hpZnQiLCJtb3ZlIiwibW92ZUJvdCIsImRyYXciLCJjYXJkSWQiLCJib3RUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwibW92ZUV2ZW50T2JqIiwibnh0UGxheWVyIiwiY2FyZCIsImdldENhcmRCeUlkIiwiY2FuUGxheUNhcmQiLCJ0YWJsZUNhcmQiLCJkcmF3Q250IiwiY2FyZHNUb0RyYXciLCJjb25jYXQiLCJnZXROZXh0UGxheWVyIiwiaGFzQ2FyZCIsInNvbWUiLCJjIiwiZmlsdGVyIiwiZmluaXNoR2FtZSIsIm1vdmVGb3J3YXJkIiwic3RlcHMiLCJ2YWxpZENhcmRzIiwicmFuZG9tQ2FyZCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInBsYXllcnNGaW5pc2hpbmdPcmRlciIsImNvbnN0cnVjdG9yIiwib2xkQ2FyZCIsIm5ld0NhcmQiLCJpc09sZERhd2luZ0NhcmQiLCJpbmRleE9mIiwiaGF2ZVRvRHJhdyIsImlzTmV3RGF3aW5nQ2FyZCIsImNvbG9yIiwiZGlnaXQiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./bots-server/BotsServer.ts\n"));

/***/ })

});