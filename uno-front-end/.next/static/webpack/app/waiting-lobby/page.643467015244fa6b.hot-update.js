"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/waiting-lobby/page",{

/***/ "(app-pages-browser)/./stores/gameStore.ts":
/*!*****************************!*\
  !*** ./stores/gameStore.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gameActions: function() { return /* binding */ gameActions; },\n/* harmony export */   useGameStore: function() { return /* binding */ useGameStore; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! immer */ \"(app-pages-browser)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var _bots_server_BotsServer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/bots-server/BotsServer */ \"(app-pages-browser)/./bots-server/BotsServer.ts\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/helpers */ \"(app-pages-browser)/./utils/helpers.ts\");\n/* __next_internal_client_entry_do_not_use__ gameActions,useGameStore auto */ \n\n\n\nconst STORAGE_KEY = \"uno-game-state\";\nconst listeners = new Set();\nconst isBrowser = \"object\" !== \"undefined\";\nlet cardLayoutIdIdx = 111;\nfunction generateDrawingCards(cnt) {\n    return Array(cnt).fill(0).map(()=>({\n            layoutId: \"id_\".concat(cardLayoutIdIdx++)\n        }));\n}\nconst initialState = {\n    playerId: \"\",\n    currentPlayer: 0,\n    nextPlayre: 0,\n    orderOffset: 0,\n    direction: 1,\n    tableStack: [],\n    drawingStack: [],\n    players: [],\n    lastPlayerDrawed: false,\n    inGame: false,\n    inLobby: false\n};\nlet state = initialState;\nconst persistState = ()=>{\n    if (!isBrowser) return;\n    try {\n        window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\n    } catch (error) {\n        console.warn(\"Unable to persist game state\", error);\n    }\n};\nconst notify = ()=>{\n    persistState();\n    listeners.forEach((listener)=>listener());\n};\nconst setState = (recipe)=>{\n    state = (0,immer__WEBPACK_IMPORTED_MODULE_3__.produce)(state, recipe);\n    notify();\n};\nif (isBrowser) {\n    try {\n        const stored = window.localStorage.getItem(STORAGE_KEY);\n        if (stored) {\n            state = {\n                ...state,\n                ...JSON.parse(stored)\n            };\n        }\n    } catch (error) {\n        console.warn(\"Failed to load stored game state\", error);\n        window.localStorage.removeItem(STORAGE_KEY);\n    }\n    window.addEventListener(\"storage\", (event)=>{\n        if (event.key !== STORAGE_KEY || !event.newValue) return;\n        try {\n            state = {\n                ...state,\n                ...JSON.parse(event.newValue)\n            };\n            listeners.forEach((listener)=>listener());\n        } catch (error) {\n            console.warn(\"Failed to sync game state from storage\", error);\n        }\n    });\n}\nconst gameActions = {\n    setPlayerId (playerId) {\n        setState((draft)=>{\n            draft.playerId = playerId;\n        });\n    },\n    init (action) {\n        setState((draft)=>{\n            const { players, cards: startingCards, firstCard } = action;\n            draft.direction = 1;\n            draft.tableStack = firstCard ? [\n                {\n                    ...firstCard,\n                    layoutId: \"table_\".concat(cardLayoutIdIdx++),\n                    rotationY: 0\n                }\n            ] : [];\n            draft.lastPlayerDrawed = false;\n            draft.inGame = true;\n            draft.inLobby = false;\n            let playersFinal = [];\n            let myIdx = 0;\n            while(myIdx < players.length){\n                if (players[myIdx].id === draft.playerId) break;\n                myIdx++;\n            }\n            for(let i = myIdx; i < players.length; i++){\n                playersFinal.push({\n                    ...players[i],\n                    cards: players[i].cards || []\n                });\n            }\n            draft.currentPlayer = playersFinal.length % players.length;\n            for(let i = 0; i < myIdx; i++){\n                playersFinal.push({\n                    ...players[i],\n                    cards: players[i].cards || []\n                });\n            }\n            let cardsToDistribute = startingCards.map((c)=>({\n                    ...c,\n                    layoutId: \"id_\".concat(cardLayoutIdIdx++),\n                    rotationY: 0,\n                    playable: myIdx === 0,\n                    forPlayer: 0\n                }));\n            for(let i = 1; i < playersFinal.length; i++){\n                cardsToDistribute = cardsToDistribute.concat(Array(startingCards.length).fill(0).map(()=>({\n                        layoutId: \"id_\".concat(cardLayoutIdIdx++),\n                        forPlayer: i\n                    })));\n            }\n            draft.players = playersFinal;\n            draft.drawingStack = cardsToDistribute.concat(generateDrawingCards(20));\n            draft.orderOffset = myIdx;\n        });\n    },\n    ready () {\n        setState((draft)=>{\n            draft.players = draft.players.map((player, idx)=>{\n                return {\n                    ...player,\n                    cards: draft.drawingStack.filter((c)=>c.forPlayer === idx)\n                };\n            });\n            draft.drawingStack = draft.drawingStack.filter((c)=>typeof c.forPlayer === \"undefined\");\n        });\n    },\n    stopGame () {\n        setState((draft)=>{\n            draft.inGame = false;\n        });\n    },\n    setInLobby (value) {\n        setState((draft)=>{\n            draft.inLobby = value;\n        });\n    },\n    moveCard (action) {\n        setState((draft)=>{\n            if (!draft.players.length) return;\n            let { curPlayer, nextPlayer, card, cardsToDraw = [], draw } = action;\n            curPlayer = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_2__.wrapMod)(curPlayer - draft.orderOffset, draft.players.length);\n            const curPlayerObj = draft.players[curPlayer];\n            if (!curPlayerObj) return;\n            nextPlayer = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_2__.wrapMod)(nextPlayer - draft.orderOffset, draft.players.length);\n            if ((card === null || card === void 0 ? void 0 : card.action) === \"reverse\") draft.direction *= -1;\n            if (draw) {\n                draft.players = draft.players.map((p)=>{\n                    if (p.id === curPlayerObj.id) {\n                        let newCards = draft.drawingStack.slice(0, draw);\n                        if (curPlayerObj.id === draft.playerId && cardsToDraw) {\n                            newCards = newCards.map((c, idx)=>({\n                                    ...c,\n                                    ...cardsToDraw[idx],\n                                    rotationY: 0\n                                }));\n                        }\n                        return {\n                            ...p,\n                            cards: p.cards.concat(newCards)\n                        };\n                    }\n                    return p;\n                });\n                draft.drawingStack = draft.drawingStack.slice(draw).concat(generateDrawingCards(draw));\n                draft.lastPlayerDrawed = true;\n            }\n            if (card) {\n                let layoutId = \"\";\n                let shouldFlip = false;\n                const hasCard = (curPlayerObj.cards || []).some((c)=>curPlayerObj.id === draft.playerId ? c.id === (card === null || card === void 0 ? void 0 : card.id) : true);\n                if (hasCard && curPlayerObj.cards.length > 0) {\n                    if (curPlayerObj.id !== draft.playerId) {\n                        layoutId = curPlayerObj.cards[Math.floor(Math.random() * curPlayerObj.cards.length)].layoutId;\n                        shouldFlip = true;\n                    } else {\n                        var _curPlayerObj_cards_find;\n                        layoutId = (_curPlayerObj_cards_find = curPlayerObj.cards.find((c)=>c.id === (card === null || card === void 0 ? void 0 : card.id))) === null || _curPlayerObj_cards_find === void 0 ? void 0 : _curPlayerObj_cards_find.layoutId;\n                        const cardToMove = curPlayerObj.cards.filter((c)=>c.layoutId === layoutId)[0];\n                        if (cardToMove) {\n                            card.color = cardToMove.color;\n                            card.action = cardToMove.action;\n                            card.digit = cardToMove.digit;\n                        }\n                    }\n                } else {\n                    layoutId = \"system_move_\".concat(cardLayoutIdIdx++);\n                    shouldFlip = true;\n                }\n                draft.tableStack = [\n                    ...draft.tableStack.slice(-1),\n                    {\n                        layoutId: layoutId || \"unknown_\".concat(cardLayoutIdIdx++),\n                        color: card.color,\n                        action: card.action,\n                        digit: card.digit,\n                        flip: shouldFlip,\n                        rotationY: 0\n                    }\n                ];\n                if (hasCard) {\n                    draft.players = draft.players.map((p)=>{\n                        if (p === curPlayerObj) {\n                            return {\n                                ...p,\n                                cards: p.cards.filter((c)=>c.layoutId !== layoutId)\n                            };\n                        }\n                        return p;\n                    });\n                }\n                draft.lastPlayerDrawed = false;\n            }\n            draft.nextPlayre = nextPlayer;\n        });\n    },\n    movePlayer () {\n        setState((draft)=>{\n            draft.players = draft.players.map((p)=>{\n                if (p.id === draft.playerId) {\n                    const myTurn = draft.nextPlayre === 0;\n                    return {\n                        ...p,\n                        cards: p.cards.map((c)=>{\n                            return {\n                                ...c,\n                                playable: myTurn && (0,_bots_server_BotsServer__WEBPACK_IMPORTED_MODULE_1__.canPlayCard)(draft.tableStack[draft.tableStack.length - 1], c, draft.lastPlayerDrawed)\n                            };\n                        })\n                    };\n                }\n                return p;\n            });\n            draft.currentPlayer = draft.nextPlayre;\n        });\n    }\n};\nconst subscribe = (listener)=>{\n    listeners.add(listener);\n    return ()=>listeners.delete(listener);\n};\nconst getSnapshot = ()=>state;\nconst getServerSnapshot = ()=>initialState;\nconst useGameStore = (selector)=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, ()=>selector(getSnapshot()), ()=>selector(getServerSnapshot()));\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LG9CQUFvQixJQUFNekY7QUFFekIsTUFBTTBGLGVBQWUsQ0FBSUM7SUFDOUIsT0FBTzFHLDJEQUFvQkEsQ0FBQ29HLFdBQVcsSUFBTU0sU0FBU0gsZ0JBQWdCLElBQ3BFRyxTQUFTRjtBQUViLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3RvcmVzL2dhbWVTdG9yZS50cz8zOTI0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgcHJvZHVjZSB9IGZyb20gJ2ltbWVyJ1xyXG5pbXBvcnQgeyBDYXJkLCBQbGF5ZXIgfSBmcm9tICdAL3V0aWxzL2ludGVyZmFjZXMnXHJcbmltcG9ydCB7IGNhblBsYXlDYXJkIH0gZnJvbSAnQC9ib3RzLXNlcnZlci9Cb3RzU2VydmVyJ1xyXG5pbXBvcnQgeyB3cmFwTW9kIH0gZnJvbSAnQC91dGlscy9oZWxwZXJzJ1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHYW1lU3RhdGUge1xyXG4gIHBsYXllcklkOiBzdHJpbmdcclxuICBjdXJyZW50UGxheWVyOiBudW1iZXJcclxuICBuZXh0UGxheXJlOiBudW1iZXJcclxuICBvcmRlck9mZnNldDogbnVtYmVyXHJcbiAgZGlyZWN0aW9uOiBudW1iZXJcclxuICB0YWJsZVN0YWNrOiBDYXJkW11cclxuICBkcmF3aW5nU3RhY2s6IENhcmRbXVxyXG4gIHBsYXllcnM6IFBsYXllcltdXHJcbiAgbGFzdFBsYXllckRyYXdlZDogYm9vbGVhblxyXG4gIGluR2FtZTogYm9vbGVhblxyXG4gIGluTG9iYnk6IGJvb2xlYW5cclxufVxyXG5cclxuY29uc3QgU1RPUkFHRV9LRVkgPSAndW5vLWdhbWUtc3RhdGUnXHJcbmNvbnN0IGxpc3RlbmVycyA9IG5ldyBTZXQ8KCkgPT4gdm9pZD4oKVxyXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xyXG5cclxubGV0IGNhcmRMYXlvdXRJZElkeCA9IDExMVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVEcmF3aW5nQ2FyZHMoY250OiBudW1iZXIpIHtcclxuICByZXR1cm4gQXJyYXkoY250KVxyXG4gICAgLmZpbGwoMClcclxuICAgIC5tYXAoKCkgPT4gKHsgbGF5b3V0SWQ6IGBpZF8ke2NhcmRMYXlvdXRJZElkeCsrfWAgfSkpXHJcbn1cclxuXHJcbmNvbnN0IGluaXRpYWxTdGF0ZTogR2FtZVN0YXRlID0ge1xyXG4gIHBsYXllcklkOiAnJyxcclxuICBjdXJyZW50UGxheWVyOiAwLFxyXG4gIG5leHRQbGF5cmU6IDAsXHJcbiAgb3JkZXJPZmZzZXQ6IDAsXHJcbiAgZGlyZWN0aW9uOiAxLFxyXG4gIHRhYmxlU3RhY2s6IFtdLFxyXG4gIGRyYXdpbmdTdGFjazogW10sXHJcbiAgcGxheWVyczogW10sXHJcbiAgbGFzdFBsYXllckRyYXdlZDogZmFsc2UsXHJcbiAgaW5HYW1lOiBmYWxzZSxcclxuICBpbkxvYmJ5OiBmYWxzZSxcclxufVxyXG5cclxubGV0IHN0YXRlOiBHYW1lU3RhdGUgPSBpbml0aWFsU3RhdGVcclxuXHJcbmNvbnN0IHBlcnNpc3RTdGF0ZSA9ICgpID0+IHtcclxuICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuXHJcbiAgdHJ5IHtcclxuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBwZXJzaXN0IGdhbWUgc3RhdGUnLCBlcnJvcilcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IG5vdGlmeSA9ICgpID0+IHtcclxuICBwZXJzaXN0U3RhdGUoKVxyXG4gIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSlcclxufVxyXG5cclxuY29uc3Qgc2V0U3RhdGUgPSAocmVjaXBlOiAoZHJhZnQ6IEdhbWVTdGF0ZSkgPT4gdm9pZCkgPT4ge1xyXG4gIHN0YXRlID0gcHJvZHVjZShzdGF0ZSwgcmVjaXBlKVxyXG4gIG5vdGlmeSgpXHJcbn1cclxuXHJcbmlmIChpc0Jyb3dzZXIpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgc3RvcmVkID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKVxyXG4gICAgaWYgKHN0b3JlZCkge1xyXG4gICAgICBzdGF0ZSA9IHsgLi4uc3RhdGUsIC4uLkpTT04ucGFyc2Uoc3RvcmVkKSB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxvYWQgc3RvcmVkIGdhbWUgc3RhdGUnLCBlcnJvcilcclxuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0tFWSlcclxuICB9XHJcblxyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgKGV2ZW50KSA9PiB7XHJcbiAgICBpZiAoZXZlbnQua2V5ICE9PSBTVE9SQUdFX0tFWSB8fCAhZXZlbnQubmV3VmFsdWUpIHJldHVyblxyXG4gICAgdHJ5IHtcclxuICAgICAgc3RhdGUgPSB7IC4uLnN0YXRlLCAuLi5KU09OLnBhcnNlKGV2ZW50Lm5ld1ZhbHVlKSB9XHJcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSlcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHN5bmMgZ2FtZSBzdGF0ZSBmcm9tIHN0b3JhZ2UnLCBlcnJvcilcclxuICAgIH1cclxuICB9KVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2FtZUFjdGlvbnMgPSB7XHJcbiAgc2V0UGxheWVySWQocGxheWVySWQ6IHN0cmluZykge1xyXG4gICAgc2V0U3RhdGUoKGRyYWZ0KSA9PiB7XHJcbiAgICAgIGRyYWZ0LnBsYXllcklkID0gcGxheWVySWRcclxuICAgIH0pXHJcbiAgfSxcclxuICBpbml0KGFjdGlvbjogeyBwbGF5ZXJzOiBQbGF5ZXJbXTsgY2FyZHM6IENhcmRbXTsgZmlyc3RDYXJkPzogQ2FyZCB9KSB7XHJcbiAgICBzZXRTdGF0ZSgoZHJhZnQpID0+IHtcclxuICAgICAgY29uc3QgeyBwbGF5ZXJzLCBjYXJkczogc3RhcnRpbmdDYXJkcywgZmlyc3RDYXJkIH0gPSBhY3Rpb25cclxuICAgICAgZHJhZnQuZGlyZWN0aW9uID0gMVxyXG4gICAgICBkcmFmdC50YWJsZVN0YWNrID0gZmlyc3RDYXJkXHJcbiAgICAgICAgPyBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAuLi5maXJzdENhcmQsXHJcbiAgICAgICAgICAgICAgbGF5b3V0SWQ6IGB0YWJsZV8ke2NhcmRMYXlvdXRJZElkeCsrfWAsXHJcbiAgICAgICAgICAgICAgcm90YXRpb25ZOiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgXVxyXG4gICAgICAgIDogW11cclxuICAgICAgZHJhZnQubGFzdFBsYXllckRyYXdlZCA9IGZhbHNlXHJcbiAgICAgIGRyYWZ0LmluR2FtZSA9IHRydWVcclxuICAgICAgZHJhZnQuaW5Mb2JieSA9IGZhbHNlXHJcblxyXG4gICAgICBsZXQgcGxheWVyc0ZpbmFsOiBQbGF5ZXJbXSA9IFtdXHJcbiAgICAgIGxldCBteUlkeCA9IDBcclxuICAgICAgd2hpbGUgKG15SWR4IDwgcGxheWVycy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocGxheWVyc1tteUlkeF0uaWQgPT09IGRyYWZ0LnBsYXllcklkKSBicmVha1xyXG4gICAgICAgIG15SWR4KytcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IG15SWR4OyBpIDwgcGxheWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBsYXllcnNGaW5hbC5wdXNoKHsgLi4ucGxheWVyc1tpXSwgY2FyZHM6IHBsYXllcnNbaV0uY2FyZHMgfHwgW10gfSlcclxuICAgICAgfVxyXG4gICAgICBkcmFmdC5jdXJyZW50UGxheWVyID0gcGxheWVyc0ZpbmFsLmxlbmd0aCAlIHBsYXllcnMubGVuZ3RoXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXlJZHg7IGkrKykge1xyXG4gICAgICAgIHBsYXllcnNGaW5hbC5wdXNoKHsgLi4ucGxheWVyc1tpXSwgY2FyZHM6IHBsYXllcnNbaV0uY2FyZHMgfHwgW10gfSlcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGNhcmRzVG9EaXN0cmlidXRlOiBDYXJkW10gPSBzdGFydGluZ0NhcmRzLm1hcCgoYykgPT4gKHtcclxuICAgICAgICAuLi5jLFxyXG4gICAgICAgIGxheW91dElkOiBgaWRfJHtjYXJkTGF5b3V0SWRJZHgrK31gLFxyXG4gICAgICAgIHJvdGF0aW9uWTogMCxcclxuICAgICAgICBwbGF5YWJsZTogbXlJZHggPT09IDAsXHJcbiAgICAgICAgZm9yUGxheWVyOiAwLFxyXG4gICAgICB9KSlcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGxheWVyc0ZpbmFsLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2FyZHNUb0Rpc3RyaWJ1dGUgPSBjYXJkc1RvRGlzdHJpYnV0ZS5jb25jYXQoXHJcbiAgICAgICAgICBBcnJheShzdGFydGluZ0NhcmRzLmxlbmd0aClcclxuICAgICAgICAgICAgLmZpbGwoMClcclxuICAgICAgICAgICAgLm1hcCgoKSA9PiAoe1xyXG4gICAgICAgICAgICAgIGxheW91dElkOiBgaWRfJHtjYXJkTGF5b3V0SWRJZHgrK31gLFxyXG4gICAgICAgICAgICAgIGZvclBsYXllcjogaSxcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcbiAgICAgIGRyYWZ0LnBsYXllcnMgPSBwbGF5ZXJzRmluYWxcclxuICAgICAgZHJhZnQuZHJhd2luZ1N0YWNrID0gY2FyZHNUb0Rpc3RyaWJ1dGUuY29uY2F0KGdlbmVyYXRlRHJhd2luZ0NhcmRzKDIwKSlcclxuICAgICAgZHJhZnQub3JkZXJPZmZzZXQgPSBteUlkeFxyXG4gICAgfSlcclxuICB9LFxyXG4gIHJlYWR5KCkge1xyXG4gICAgc2V0U3RhdGUoKGRyYWZ0KSA9PiB7XHJcbiAgICAgIGRyYWZ0LnBsYXllcnMgPSBkcmFmdC5wbGF5ZXJzLm1hcCgocGxheWVyLCBpZHgpID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgLi4ucGxheWVyLFxyXG4gICAgICAgICAgY2FyZHM6IGRyYWZ0LmRyYXdpbmdTdGFjay5maWx0ZXIoKGMpID0+IGMuZm9yUGxheWVyID09PSBpZHgpLFxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIGRyYWZ0LmRyYXdpbmdTdGFjayA9IGRyYWZ0LmRyYXdpbmdTdGFjay5maWx0ZXIoXHJcbiAgICAgICAgKGMpID0+IHR5cGVvZiBjLmZvclBsYXllciA9PT0gJ3VuZGVmaW5lZCdcclxuICAgICAgKVxyXG4gICAgfSlcclxuICB9LFxyXG4gIHN0b3BHYW1lKCkge1xyXG4gICAgc2V0U3RhdGUoKGRyYWZ0KSA9PiB7XHJcbiAgICAgIGRyYWZ0LmluR2FtZSA9IGZhbHNlXHJcbiAgICB9KVxyXG4gIH0sXHJcbiAgc2V0SW5Mb2JieSh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgc2V0U3RhdGUoKGRyYWZ0KSA9PiB7XHJcbiAgICAgIGRyYWZ0LmluTG9iYnkgPSB2YWx1ZVxyXG4gICAgfSlcclxuICB9LFxyXG4gIG1vdmVDYXJkKGFjdGlvbjoge1xyXG4gICAgY3VyUGxheWVyOiBudW1iZXJcclxuICAgIG5leHRQbGF5ZXI6IG51bWJlclxyXG4gICAgY2FyZD86IENhcmRcclxuICAgIGRyYXc/OiBudW1iZXJcclxuICAgIGNhcmRzVG9EcmF3PzogQ2FyZFtdXHJcbiAgfSkge1xyXG4gICAgc2V0U3RhdGUoKGRyYWZ0KSA9PiB7XHJcbiAgICAgIGlmICghZHJhZnQucGxheWVycy5sZW5ndGgpIHJldHVyblxyXG4gICAgICBsZXQgeyBjdXJQbGF5ZXIsIG5leHRQbGF5ZXIsIGNhcmQsIGNhcmRzVG9EcmF3ID0gW10sIGRyYXcgfSA9IGFjdGlvblxyXG5cclxuICAgICAgY3VyUGxheWVyID0gd3JhcE1vZChjdXJQbGF5ZXIgLSBkcmFmdC5vcmRlck9mZnNldCwgZHJhZnQucGxheWVycy5sZW5ndGgpXHJcbiAgICAgIGNvbnN0IGN1clBsYXllck9iaiA9IGRyYWZ0LnBsYXllcnNbY3VyUGxheWVyXVxyXG4gICAgICBpZiAoIWN1clBsYXllck9iaikgcmV0dXJuXHJcblxyXG4gICAgICBuZXh0UGxheWVyID0gd3JhcE1vZChuZXh0UGxheWVyIC0gZHJhZnQub3JkZXJPZmZzZXQsIGRyYWZ0LnBsYXllcnMubGVuZ3RoKVxyXG5cclxuICAgICAgaWYgKGNhcmQ/LmFjdGlvbiA9PT0gJ3JldmVyc2UnKSBkcmFmdC5kaXJlY3Rpb24gKj0gLTFcclxuXHJcbiAgICAgIGlmIChkcmF3KSB7XHJcbiAgICAgICAgZHJhZnQucGxheWVycyA9IGRyYWZ0LnBsYXllcnMubWFwKChwKSA9PiB7XHJcbiAgICAgICAgICBpZiAocC5pZCA9PT0gY3VyUGxheWVyT2JqLmlkKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdDYXJkcyA9IGRyYWZ0LmRyYXdpbmdTdGFjay5zbGljZSgwLCBkcmF3KVxyXG4gICAgICAgICAgICBpZiAoY3VyUGxheWVyT2JqLmlkID09PSBkcmFmdC5wbGF5ZXJJZCAmJiBjYXJkc1RvRHJhdykge1xyXG4gICAgICAgICAgICAgIG5ld0NhcmRzID0gbmV3Q2FyZHMubWFwKChjLCBpZHgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAuLi5jLFxyXG4gICAgICAgICAgICAgICAgLi4uY2FyZHNUb0RyYXdbaWR4XSxcclxuICAgICAgICAgICAgICAgIHJvdGF0aW9uWTogMCxcclxuICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgICAgY2FyZHM6IHAuY2FyZHMuY29uY2F0KG5ld0NhcmRzKSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHBcclxuICAgICAgICB9KVxyXG4gICAgICAgIGRyYWZ0LmRyYXdpbmdTdGFjayA9IGRyYWZ0LmRyYXdpbmdTdGFjay5zbGljZShkcmF3KS5jb25jYXQoZ2VuZXJhdGVEcmF3aW5nQ2FyZHMoZHJhdykpXHJcbiAgICAgICAgZHJhZnQubGFzdFBsYXllckRyYXdlZCA9IHRydWVcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhcmQpIHtcclxuICAgICAgICBsZXQgbGF5b3V0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9ICcnXHJcbiAgICAgICAgbGV0IHNob3VsZEZsaXAgPSBmYWxzZVxyXG5cclxuICAgICAgICBjb25zdCBoYXNDYXJkID0gKGN1clBsYXllck9iai5jYXJkcyB8fCBbXSkuc29tZSgoYykgPT5cclxuICAgICAgICAgIGN1clBsYXllck9iai5pZCA9PT0gZHJhZnQucGxheWVySWQgPyBjLmlkID09PSBjYXJkPy5pZCA6IHRydWVcclxuICAgICAgICApXHJcblxyXG4gICAgICAgIGlmIChoYXNDYXJkICYmIGN1clBsYXllck9iai5jYXJkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBpZiAoY3VyUGxheWVyT2JqLmlkICE9PSBkcmFmdC5wbGF5ZXJJZCkge1xyXG4gICAgICAgICAgICBsYXlvdXRJZCA9XHJcbiAgICAgICAgICAgICAgY3VyUGxheWVyT2JqLmNhcmRzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGN1clBsYXllck9iai5jYXJkcy5sZW5ndGgpXS5sYXlvdXRJZFxyXG4gICAgICAgICAgICBzaG91bGRGbGlwID0gdHJ1ZVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGF5b3V0SWQgPSBjdXJQbGF5ZXJPYmouY2FyZHMuZmluZCgoYykgPT4gYy5pZCA9PT0gY2FyZD8uaWQpPy5sYXlvdXRJZFxyXG4gICAgICAgICAgICBjb25zdCBjYXJkVG9Nb3ZlID0gY3VyUGxheWVyT2JqLmNhcmRzLmZpbHRlcigoYykgPT4gYy5sYXlvdXRJZCA9PT0gbGF5b3V0SWQpWzBdXHJcblxyXG4gICAgICAgICAgICBpZiAoY2FyZFRvTW92ZSkge1xyXG4gICAgICAgICAgICAgIGNhcmQuY29sb3IgPSBjYXJkVG9Nb3ZlLmNvbG9yXHJcbiAgICAgICAgICAgICAgY2FyZC5hY3Rpb24gPSBjYXJkVG9Nb3ZlLmFjdGlvblxyXG4gICAgICAgICAgICAgIGNhcmQuZGlnaXQgPSBjYXJkVG9Nb3ZlLmRpZ2l0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGF5b3V0SWQgPSBgc3lzdGVtX21vdmVfJHtjYXJkTGF5b3V0SWRJZHgrK31gXHJcbiAgICAgICAgICBzaG91bGRGbGlwID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHJhZnQudGFibGVTdGFjayA9IFtcclxuICAgICAgICAgIC4uLmRyYWZ0LnRhYmxlU3RhY2suc2xpY2UoLTEpLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBsYXlvdXRJZDogbGF5b3V0SWQgfHwgYHVua25vd25fJHtjYXJkTGF5b3V0SWRJZHgrK31gLFxyXG4gICAgICAgICAgICBjb2xvcjogY2FyZC5jb2xvcixcclxuICAgICAgICAgICAgYWN0aW9uOiBjYXJkLmFjdGlvbixcclxuICAgICAgICAgICAgZGlnaXQ6IGNhcmQuZGlnaXQsXHJcbiAgICAgICAgICAgIGZsaXA6IHNob3VsZEZsaXAsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uWTogMCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXVxyXG5cclxuICAgICAgICBpZiAoaGFzQ2FyZCkge1xyXG4gICAgICAgICAgZHJhZnQucGxheWVycyA9IGRyYWZ0LnBsYXllcnMubWFwKChwKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwID09PSBjdXJQbGF5ZXJPYmopIHtcclxuICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICAgIGNhcmRzOiBwLmNhcmRzLmZpbHRlcigoYykgPT4gYy5sYXlvdXRJZCAhPT0gbGF5b3V0SWQpLFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJhZnQubGFzdFBsYXllckRyYXdlZCA9IGZhbHNlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRyYWZ0Lm5leHRQbGF5cmUgPSBuZXh0UGxheWVyXHJcbiAgICB9KVxyXG4gIH0sXHJcbiAgbW92ZVBsYXllcigpIHtcclxuICAgIHNldFN0YXRlKChkcmFmdCkgPT4ge1xyXG4gICAgICBkcmFmdC5wbGF5ZXJzID0gZHJhZnQucGxheWVycy5tYXAoKHApID0+IHtcclxuICAgICAgICBpZiAocC5pZCA9PT0gZHJhZnQucGxheWVySWQpIHtcclxuICAgICAgICAgIGNvbnN0IG15VHVybiA9IGRyYWZ0Lm5leHRQbGF5cmUgPT09IDBcclxuXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5wLFxyXG4gICAgICAgICAgICBjYXJkczogcC5jYXJkcy5tYXAoKGMpID0+IHtcclxuICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4uYyxcclxuICAgICAgICAgICAgICAgIHBsYXlhYmxlOlxyXG4gICAgICAgICAgICAgICAgICBteVR1cm4gJiZcclxuICAgICAgICAgICAgICAgICAgY2FuUGxheUNhcmQoXHJcbiAgICAgICAgICAgICAgICAgICAgZHJhZnQudGFibGVTdGFja1tkcmFmdC50YWJsZVN0YWNrLmxlbmd0aCAtIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGMsXHJcbiAgICAgICAgICAgICAgICAgICAgZHJhZnQubGFzdFBsYXllckRyYXdlZFxyXG4gICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwXHJcbiAgICAgIH0pXHJcbiAgICAgIGRyYWZ0LmN1cnJlbnRQbGF5ZXIgPSBkcmFmdC5uZXh0UGxheXJlXHJcbiAgICB9KVxyXG4gIH0sXHJcbn1cclxuXHJcbmNvbnN0IHN1YnNjcmliZSA9IChsaXN0ZW5lcjogKCkgPT4gdm9pZCkgPT4ge1xyXG4gIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpXHJcbiAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpXHJcbn1cclxuXHJcbmNvbnN0IGdldFNuYXBzaG90ID0gKCkgPT4gc3RhdGVcclxuY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSAoKSA9PiBpbml0aWFsU3RhdGVcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VHYW1lU3RvcmUgPSA8VD4oc2VsZWN0b3I6IChzdGF0ZTogR2FtZVN0YXRlKSA9PiBUKSA9PiB7XHJcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgKCkgPT4gc2VsZWN0b3IoZ2V0U25hcHNob3QoKSksICgpID0+XHJcbiAgICBzZWxlY3RvcihnZXRTZXJ2ZXJTbmFwc2hvdCgpKVxyXG4gIClcclxufVxyXG5cclxuXHJcbiJdLCJuYW1lcyI6WyJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInByb2R1Y2UiLCJjYW5QbGF5Q2FyZCIsIndyYXBNb2QiLCJTVE9SQUdFX0tFWSIsImxpc3RlbmVycyIsIlNldCIsImlzQnJvd3NlciIsImNhcmRMYXlvdXRJZElkeCIsImdlbmVyYXRlRHJhd2luZ0NhcmRzIiwiY250IiwiQXJyYXkiLCJmaWxsIiwibWFwIiwibGF5b3V0SWQiLCJpbml0aWFsU3RhdGUiLCJwbGF5ZXJJZCIsImN1cnJlbnRQbGF5ZXIiLCJuZXh0UGxheXJlIiwib3JkZXJPZmZzZXQiLCJkaXJlY3Rpb24iLCJ0YWJsZVN0YWNrIiwiZHJhd2luZ1N0YWNrIiwicGxheWVycyIsImxhc3RQbGF5ZXJEcmF3ZWQiLCJpbkdhbWUiLCJpbkxvYmJ5Iiwic3RhdGUiLCJwZXJzaXN0U3RhdGUiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJub3RpZnkiLCJmb3JFYWNoIiwibGlzdGVuZXIiLCJzZXRTdGF0ZSIsInJlY2lwZSIsInN0b3JlZCIsImdldEl0ZW0iLCJwYXJzZSIsInJlbW92ZUl0ZW0iLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJrZXkiLCJuZXdWYWx1ZSIsImdhbWVBY3Rpb25zIiwic2V0UGxheWVySWQiLCJkcmFmdCIsImluaXQiLCJhY3Rpb24iLCJjYXJkcyIsInN0YXJ0aW5nQ2FyZHMiLCJmaXJzdENhcmQiLCJyb3RhdGlvblkiLCJwbGF5ZXJzRmluYWwiLCJteUlkeCIsImxlbmd0aCIsImlkIiwiaSIsInB1c2giLCJjYXJkc1RvRGlzdHJpYnV0ZSIsImMiLCJwbGF5YWJsZSIsImZvclBsYXllciIsImNvbmNhdCIsInJlYWR5IiwicGxheWVyIiwiaWR4IiwiZmlsdGVyIiwic3RvcEdhbWUiLCJzZXRJbkxvYmJ5IiwidmFsdWUiLCJtb3ZlQ2FyZCIsImN1clBsYXllciIsIm5leHRQbGF5ZXIiLCJjYXJkIiwiY2FyZHNUb0RyYXciLCJkcmF3IiwiY3VyUGxheWVyT2JqIiwicCIsIm5ld0NhcmRzIiwic2xpY2UiLCJzaG91bGRGbGlwIiwiaGFzQ2FyZCIsInNvbWUiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJmaW5kIiwiY2FyZFRvTW92ZSIsImNvbG9yIiwiZGlnaXQiLCJmbGlwIiwibW92ZVBsYXllciIsIm15VHVybiIsInN1YnNjcmliZSIsImFkZCIsImRlbGV0ZSIsImdldFNuYXBzaG90IiwiZ2V0U2VydmVyU25hcHNob3QiLCJ1c2VHYW1lU3RvcmUiLCJzZWxlY3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./stores/gameStore.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./utils/hooks.ts":
/*!************************!*\
  !*** ./utils/hooks.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameActions: function() { return /* binding */ useGameActions; },\n/* harmony export */   useGameStoreSelector: function() { return /* binding */ useGameStoreSelector; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stores_gameStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/gameStore */ \"(app-pages-browser)/./stores/gameStore.ts\");\n/* __next_internal_client_entry_do_not_use__ useGameActions,useGameStoreSelector auto */ \n\nconst useGameActions = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>_stores_gameStore__WEBPACK_IMPORTED_MODULE_1__.gameActions, []);\nconst useGameStoreSelector = _stores_gameStore__WEBPACK_IMPORTED_MODULE_1__.useGameStore;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2hvb2tzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3lGQUUrQjtBQUMrQjtBQUV2RCxNQUFNRyxpQkFBaUIsSUFBTUgsOENBQU9BLENBQUMsSUFBTUMsMERBQVdBLEVBQUUsRUFBRSxFQUFDO0FBQzNELE1BQU1HLHVCQUF1QkYsMkRBQVlBLENBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvaG9va3MudHM/YjNmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgZ2FtZUFjdGlvbnMsIHVzZUdhbWVTdG9yZSB9IGZyb20gJ0Avc3RvcmVzL2dhbWVTdG9yZSdcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VHYW1lQWN0aW9ucyA9ICgpID0+IHVzZU1lbW8oKCkgPT4gZ2FtZUFjdGlvbnMsIFtdKVxyXG5leHBvcnQgY29uc3QgdXNlR2FtZVN0b3JlU2VsZWN0b3IgPSB1c2VHYW1lU3RvcmVcclxuXHJcblxyXG4iXSwibmFtZXMiOlsidXNlTWVtbyIsImdhbWVBY3Rpb25zIiwidXNlR2FtZVN0b3JlIiwidXNlR2FtZUFjdGlvbnMiLCJ1c2VHYW1lU3RvcmVTZWxlY3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/hooks.ts\n"));

/***/ })

});