"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/waiting-lobby/page",{

/***/ "(app-pages-browser)/./stores/features/gameSlice.ts":
/*!**************************************!*\
  !*** ./stores/features/gameSlice.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gameSlice: function() { return /* binding */ gameSlice; },\n/* harmony export */   init: function() { return /* binding */ init; },\n/* harmony export */   moveCard: function() { return /* binding */ moveCard; },\n/* harmony export */   movePlayer: function() { return /* binding */ movePlayer; },\n/* harmony export */   ready: function() { return /* binding */ ready; },\n/* harmony export */   setInLobby: function() { return /* binding */ setInLobby; },\n/* harmony export */   setPlayerId: function() { return /* binding */ setPlayerId; },\n/* harmony export */   stopGame: function() { return /* binding */ stopGame; }\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(app-pages-browser)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _bots_server_BotsServer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/bots-server/BotsServer */ \"(app-pages-browser)/./bots-server/BotsServer.ts\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/helpers */ \"(app-pages-browser)/./utils/helpers.ts\");\n\n\n\nlet cardLayoutIdIdx = 111;\nfunction generateDrawingCards(cnt) {\n    return Array(cnt).fill(0).map(()=>({\n            layoutId: \"id_\".concat(cardLayoutIdIdx++)\n        }));\n}\nconst initialState = {\n    playerId: \"\",\n    currentPlayer: 0,\n    nextPlayre: 0,\n    orderOffset: 0,\n    direction: 1,\n    tableStack: [],\n    drawingStack: [],\n    players: [],\n    lastPlayerDrawed: false,\n    inGame: false,\n    inLobby: false\n};\nconst gameSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__.createSlice)({\n    name: \"game\",\n    initialState,\n    reducers: {\n        setPlayerId (state, action) {\n            state.playerId = action.payload;\n        },\n        init: (state, action)=>{\n            const { players, cards: startingCards, firstCard } = action.payload;\n            state.direction = 1;\n            state.tableStack = firstCard ? [\n                {\n                    ...firstCard,\n                    layoutId: \"table_\".concat(cardLayoutIdIdx++),\n                    rotationY: 0\n                }\n            ] : [];\n            state.lastPlayerDrawed = false;\n            state.inGame = true;\n            state.inLobby = false;\n            let playersFinal = [];\n            let myIdx = 0;\n            while(myIdx < players.length){\n                if (players[myIdx].id === state.playerId) break;\n                myIdx++;\n            }\n            for(let i = myIdx; i < players.length; i++){\n                playersFinal.push(players[i]);\n            }\n            state.currentPlayer = playersFinal.length % players.length;\n            for(let i = 0; i < myIdx; i++){\n                playersFinal.push(players[i]);\n            }\n            let cardsToDistribute = startingCards.map((c)=>({\n                    ...c,\n                    layoutId: \"id_\".concat(cardLayoutIdIdx++),\n                    rotationY: 0,\n                    playable: myIdx === 0,\n                    forPlayer: 0\n                }));\n            for(let i = 1; i < playersFinal.length; i++){\n                cardsToDistribute = cardsToDistribute.concat(Array(startingCards.length).fill(0).map(()=>({\n                        layoutId: \"id_\".concat(cardLayoutIdIdx++),\n                        forPlayer: i\n                    })));\n            }\n            state.players = playersFinal;\n            state.drawingStack = cardsToDistribute.concat(generateDrawingCards(20));\n            state.orderOffset = myIdx;\n        },\n        ready (state) {\n            state.players = state.players.map((player, idx)=>{\n                return {\n                    ...player,\n                    cards: state.drawingStack.filter((c)=>c.forPlayer === idx)\n                };\n            });\n            state.drawingStack = state.drawingStack.filter((c)=>typeof c.forPlayer === \"undefined\");\n        },\n        stopGame (state) {\n            state.inGame = false;\n        },\n        setInLobby (state, action) {\n            state.inLobby = action.payload;\n        },\n        moveCard (state, action) {\n            let { curPlayer, nextPlayer, card, cardsToDraw = [], draw } = action.payload;\n            // Convert curPlayer from server index to UI index\n            curPlayer = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.wrapMod)(curPlayer - state.orderOffset, state.players.length);\n            const curPlayerObj = state.players[curPlayer];\n            nextPlayer = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.wrapMod)(nextPlayer - state.orderOffset, state.players.length);\n            if ((card === null || card === void 0 ? void 0 : card.action) === \"reverse\") state.direction *= -1;\n            if (draw) {\n                state.players = state.players.map((p)=>{\n                    if (p.id === curPlayerObj.id) {\n                        let newCards = state.drawingStack.slice(0, draw);\n                        if (curPlayerObj.id === state.playerId && cardsToDraw) {\n                            newCards = newCards.map((c, idx)=>({\n                                    ...c,\n                                    ...cardsToDraw[idx],\n                                    rotationY: 0\n                                }));\n                        }\n                        return {\n                            ...p,\n                            cards: p.cards.concat(newCards)\n                        };\n                    }\n                    return p;\n                });\n                state.drawingStack = state.drawingStack.slice(draw).concat(generateDrawingCards(draw));\n                state.lastPlayerDrawed = true;\n            }\n            if (card) {\n                let layoutId = \"\";\n                let shouldFlip = false;\n                // Check if player actually has the card (or any card if not local player)\n                const hasCard = curPlayerObj.cards.some((c)=>curPlayerObj.id === state.playerId ? c.id === (card === null || card === void 0 ? void 0 : card.id) : true);\n                if (hasCard && curPlayerObj.cards.length > 0) {\n                    if (curPlayerObj.id !== state.playerId) {\n                        layoutId = curPlayerObj.cards[Math.floor(Math.random() * curPlayerObj.cards.length)].layoutId;\n                        shouldFlip = true;\n                    } else {\n                        var _curPlayerObj_cards_find;\n                        layoutId = (_curPlayerObj_cards_find = curPlayerObj.cards.find((c)=>c.id === (card === null || card === void 0 ? void 0 : card.id))) === null || _curPlayerObj_cards_find === void 0 ? void 0 : _curPlayerObj_cards_find.layoutId;\n                        const cardToMove = curPlayerObj.cards.filter((c)=>c.layoutId === layoutId)[0];\n                        if (cardToMove) {\n                            card.color = cardToMove.color;\n                            card.action = cardToMove.action;\n                            card.digit = cardToMove.digit;\n                        }\n                    }\n                } else {\n                    // Card not in hand (e.g. first card played by system)\n                    // Animate from drawing stack (deck)\n                    layoutId = \"system_move_\".concat(cardLayoutIdIdx++);\n                    shouldFlip = true;\n                }\n                state.tableStack = [\n                    ...state.tableStack.slice(-1),\n                    {\n                        layoutId: layoutId || \"unknown_\".concat(cardLayoutIdIdx++),\n                        color: card.color,\n                        action: card.action,\n                        digit: card.digit,\n                        flip: shouldFlip,\n                        rotationY: 0\n                    }\n                ];\n                // Only remove card if it was in hand\n                if (hasCard) {\n                    state.players = state.players.map((p)=>{\n                        if (p === curPlayerObj) {\n                            return {\n                                ...p,\n                                cards: p.cards.filter((c)=>c.layoutId !== layoutId)\n                            };\n                        }\n                        return p;\n                    });\n                }\n                state.lastPlayerDrawed = false;\n            }\n            state.nextPlayre = nextPlayer;\n        },\n        movePlayer (state) {\n            state.players = state.players.map((p)=>{\n                if (p.id === state.playerId) {\n                    const myTurn = state.nextPlayre === 0;\n                    return {\n                        ...p,\n                        cards: p.cards.map((c)=>{\n                            return {\n                                ...c,\n                                playable: myTurn && (0,_bots_server_BotsServer__WEBPACK_IMPORTED_MODULE_0__.canPlayCard)(state.tableStack[state.tableStack.length - 1], c, state.lastPlayerDrawed)\n                            };\n                        })\n                    };\n                }\n                return p;\n            });\n            state.currentPlayer = state.nextPlayre;\n        }\n    }\n});\nconst { init, ready, stopGame, moveCard, movePlayer, setInLobby, setPlayerId } = gameSlice.actions;\n/* harmony default export */ __webpack_exports__[\"default\"] = (gameSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3Jlcy9mZWF0dXJlcy9nYW1lU2xpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDUDtBQUNiO0FBaUJ6QyxJQUFJRyxrQkFBa0I7QUFFdEIsU0FBU0MscUJBQXFCQyxHQUFXO0lBQ3ZDLE9BQU9DLE1BQU1ELEtBQ1ZFLElBQUksQ0FBQyxHQUNMQyxHQUFHLENBQUMsSUFBTztZQUFFQyxVQUFVLE1BQXdCLE9BQWxCTjtRQUFvQjtBQUN0RDtBQUVBLE1BQU1PLGVBQTJCO0lBQy9CQyxVQUFVO0lBQ1ZDLGVBQWU7SUFDZkMsWUFBWTtJQUNaQyxhQUFhO0lBQ2JDLFdBQVc7SUFDWEMsWUFBWSxFQUFFO0lBQ2RDLGNBQWMsRUFBRTtJQUNoQkMsU0FBUyxFQUFFO0lBQ1hDLGtCQUFrQjtJQUNsQkMsUUFBUTtJQUNSQyxTQUFTO0FBQ1g7QUFFTyxNQUFNQyxZQUFZdEIsNkRBQVdBLENBQUM7SUFDbkN1QixNQUFNO0lBQ05iO0lBQ0FjLFVBQVU7UUFDUkMsYUFBWUMsS0FBSyxFQUFFQyxNQUE2QjtZQUM5Q0QsTUFBTWYsUUFBUSxHQUFHZ0IsT0FBT0MsT0FBTztRQUNqQztRQUNBQyxNQUFNLENBQ0pILE9BQ0FDO1lBRUEsTUFBTSxFQUFFVCxPQUFPLEVBQUVZLE9BQU9DLGFBQWEsRUFBRUMsU0FBUyxFQUFFLEdBQUdMLE9BQU9DLE9BQU87WUFDbkVGLE1BQU1YLFNBQVMsR0FBRztZQUNsQlcsTUFBTVYsVUFBVSxHQUFHZ0IsWUFBWTtnQkFBQztvQkFDOUIsR0FBR0EsU0FBUztvQkFDWnZCLFVBQVUsU0FBMkIsT0FBbEJOO29CQUNuQjhCLFdBQVc7Z0JBQ2I7YUFBRSxHQUFHLEVBQUU7WUFDUFAsTUFBTVAsZ0JBQWdCLEdBQUc7WUFDekJPLE1BQU1OLE1BQU0sR0FBRztZQUNmTSxNQUFNTCxPQUFPLEdBQUc7WUFFaEIsSUFBSWEsZUFBeUIsRUFBRTtZQUMvQixJQUFJQyxRQUFRO1lBQ1osTUFBT0EsUUFB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aEMsTUFBTVAsZ0JBQWdCLEdBQUc7WUFDM0I7WUFFQU8sTUFBTWIsVUFBVSxHQUFHd0M7UUFDckI7UUFDQW1CLFlBQVc5QyxLQUFLO1lBQ2RBLE1BQU1SLE9BQU8sR0FBR1EsTUFBTVIsT0FBTyxDQUFDVixHQUFHLENBQUMsQ0FBQ2tEO2dCQUNqQyxJQUFJQSxFQUFFckIsRUFBRSxLQUFLWCxNQUFNZixRQUFRLEVBQUU7b0JBQzNCLE1BQU04RCxTQUFTL0MsTUFBTWIsVUFBVSxLQUFLO29CQUVwQyxPQUFPO3dCQUNMLEdBQUc2QyxDQUFDO3dCQUNKNUIsT0FBTzRCLEVBQUU1QixLQUFLLENBQUN0QixHQUFHLENBQUMsQ0FBQ2lDOzRCQUNsQixPQUFPO2dDQUNMLEdBQUdBLENBQUM7Z0NBQ0pDLFVBQ0UrQixVQUNBeEUsb0VBQVdBLENBQ1R5QixNQUFNVixVQUFVLENBQUNVLE1BQU1WLFVBQVUsQ0FBQ29CLE1BQU0sR0FBRyxFQUFFLEVBQzdDSyxHQUNBZixNQUFNUCxnQkFBZ0I7NEJBRTVCO3dCQUNGO29CQUNGO2dCQUNGO2dCQUNBLE9BQU91QztZQUNUO1lBQ0FoQyxNQUFNZCxhQUFhLEdBQUdjLE1BQU1iLFVBQVU7UUFDeEM7SUFDRjtBQUNGLEdBQUU7QUFFSyxNQUFNLEVBQ1hnQixJQUFJLEVBQ0pnQixLQUFLLEVBQ0xJLFFBQVEsRUFDUkUsUUFBUSxFQUNScUIsVUFBVSxFQUNWdEIsVUFBVSxFQUNWekIsV0FBVyxFQUNaLEdBQUdILFVBQVVvRCxPQUFPO0FBRXJCLCtEQUFlcEQsVUFBVXFELE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3RvcmVzL2ZlYXR1cmVzL2dhbWVTbGljZS50cz9jMDFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNsaWNlLCBQYXlsb2FkQWN0aW9uIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCdcclxuaW1wb3J0IHsgY2FuUGxheUNhcmQgfSBmcm9tICdAL2JvdHMtc2VydmVyL0JvdHNTZXJ2ZXInXHJcbmltcG9ydCB7IHdyYXBNb2QgfSBmcm9tICdAL3V0aWxzL2hlbHBlcnMnXHJcbmltcG9ydCB7IENhcmQsIFBsYXllciB9IGZyb20gJ0AvdXRpbHMvaW50ZXJmYWNlcydcclxuXHJcbmludGVyZmFjZSBTdG9yZVN0YXRlIHtcclxuICBwbGF5ZXJJZDogc3RyaW5nXHJcbiAgY3VycmVudFBsYXllcjogbnVtYmVyXHJcbiAgbmV4dFBsYXlyZTogbnVtYmVyXHJcbiAgb3JkZXJPZmZzZXQ6IG51bWJlclxyXG4gIGRpcmVjdGlvbjogbnVtYmVyXHJcbiAgdGFibGVTdGFjazogQ2FyZFtdXHJcbiAgZHJhd2luZ1N0YWNrOiBDYXJkW11cclxuICBwbGF5ZXJzOiBQbGF5ZXJbXVxyXG4gIGxhc3RQbGF5ZXJEcmF3ZWQ6IGJvb2xlYW5cclxuICBpbkdhbWU6IGJvb2xlYW5cclxuICBpbkxvYmJ5OiBib29sZWFuXHJcbn1cclxuXHJcbmxldCBjYXJkTGF5b3V0SWRJZHggPSAxMTFcclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlRHJhd2luZ0NhcmRzKGNudDogbnVtYmVyKSB7XHJcbiAgcmV0dXJuIEFycmF5KGNudClcclxuICAgIC5maWxsKDApXHJcbiAgICAubWFwKCgpID0+ICh7IGxheW91dElkOiBgaWRfJHtjYXJkTGF5b3V0SWRJZHgrK31gIH0pKVxyXG59XHJcblxyXG5jb25zdCBpbml0aWFsU3RhdGU6IFN0b3JlU3RhdGUgPSB7XHJcbiAgcGxheWVySWQ6ICcnLFxyXG4gIGN1cnJlbnRQbGF5ZXI6IDAsXHJcbiAgbmV4dFBsYXlyZTogMCxcclxuICBvcmRlck9mZnNldDogMCxcclxuICBkaXJlY3Rpb246IDEsXHJcbiAgdGFibGVTdGFjazogW10sXHJcbiAgZHJhd2luZ1N0YWNrOiBbXSxcclxuICBwbGF5ZXJzOiBbXSxcclxuICBsYXN0UGxheWVyRHJhd2VkOiBmYWxzZSxcclxuICBpbkdhbWU6IGZhbHNlLFxyXG4gIGluTG9iYnk6IGZhbHNlLFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2FtZVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xyXG4gIG5hbWU6ICdnYW1lJyxcclxuICBpbml0aWFsU3RhdGUsXHJcbiAgcmVkdWNlcnM6IHtcclxuICAgIHNldFBsYXllcklkKHN0YXRlLCBhY3Rpb246IFBheWxvYWRBY3Rpb248c3RyaW5nPikge1xyXG4gICAgICBzdGF0ZS5wbGF5ZXJJZCA9IGFjdGlvbi5wYXlsb2FkXHJcbiAgICB9LFxyXG4gICAgaW5pdDogKFxyXG4gICAgICBzdGF0ZSxcclxuICAgICAgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPHsgcGxheWVyczogUGxheWVyW107IGNhcmRzOiBDYXJkW107IGZpcnN0Q2FyZD86IENhcmQgfT5cclxuICAgICkgPT4ge1xyXG4gICAgICBjb25zdCB7IHBsYXllcnMsIGNhcmRzOiBzdGFydGluZ0NhcmRzLCBmaXJzdENhcmQgfSA9IGFjdGlvbi5wYXlsb2FkXHJcbiAgICAgIHN0YXRlLmRpcmVjdGlvbiA9IDFcclxuICAgICAgc3RhdGUudGFibGVTdGFjayA9IGZpcnN0Q2FyZCA/IFt7XHJcbiAgICAgICAgLi4uZmlyc3RDYXJkLFxyXG4gICAgICAgIGxheW91dElkOiBgdGFibGVfJHtjYXJkTGF5b3V0SWRJZHgrK31gLFxyXG4gICAgICAgIHJvdGF0aW9uWTogMCxcclxuICAgICAgfV0gOiBbXVxyXG4gICAgICBzdGF0ZS5sYXN0UGxheWVyRHJhd2VkID0gZmFsc2VcclxuICAgICAgc3RhdGUuaW5HYW1lID0gdHJ1ZVxyXG4gICAgICBzdGF0ZS5pbkxvYmJ5ID0gZmFsc2VcclxuXHJcbiAgICAgIGxldCBwbGF5ZXJzRmluYWw6IFBsYXllcltdID0gW11cclxuICAgICAgbGV0IG15SWR4ID0gMFxyXG4gICAgICB3aGlsZSAobXlJZHggPCBwbGF5ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChwbGF5ZXJzW215SWR4XS5pZCA9PT0gc3RhdGUucGxheWVySWQpIGJyZWFrXHJcbiAgICAgICAgbXlJZHgrK1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gbXlJZHg7IGkgPCBwbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcGxheWVyc0ZpbmFsLnB1c2gocGxheWVyc1tpXSlcclxuICAgICAgfVxyXG4gICAgICBzdGF0ZS5jdXJyZW50UGxheWVyID0gcGxheWVyc0ZpbmFsLmxlbmd0aCAlIHBsYXllcnMubGVuZ3RoXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXlJZHg7IGkrKykge1xyXG4gICAgICAgIHBsYXllcnNGaW5hbC5wdXNoKHBsYXllcnNbaV0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBjYXJkc1RvRGlzdHJpYnV0ZTogQ2FyZFtdID0gc3RhcnRpbmdDYXJkcy5tYXAoKGMpID0+ICh7XHJcbiAgICAgICAgLi4uYyxcclxuICAgICAgICBsYXlvdXRJZDogYGlkXyR7Y2FyZExheW91dElkSWR4Kyt9YCxcclxuICAgICAgICByb3RhdGlvblk6IDAsXHJcbiAgICAgICAgcGxheWFibGU6IG15SWR4ID09PSAwLFxyXG4gICAgICAgIGZvclBsYXllcjogMCxcclxuICAgICAgfSkpXHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBsYXllcnNGaW5hbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNhcmRzVG9EaXN0cmlidXRlID0gY2FyZHNUb0Rpc3RyaWJ1dGUuY29uY2F0KFxyXG4gICAgICAgICAgQXJyYXkoc3RhcnRpbmdDYXJkcy5sZW5ndGgpXHJcbiAgICAgICAgICAgIC5maWxsKDApXHJcbiAgICAgICAgICAgIC5tYXAoKCkgPT4gKHtcclxuICAgICAgICAgICAgICBsYXlvdXRJZDogYGlkXyR7Y2FyZExheW91dElkSWR4Kyt9YCxcclxuICAgICAgICAgICAgICBmb3JQbGF5ZXI6IGksXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG4gICAgICBzdGF0ZS5wbGF5ZXJzID0gcGxheWVyc0ZpbmFsXHJcbiAgICAgIHN0YXRlLmRyYXdpbmdTdGFjayA9IGNhcmRzVG9EaXN0cmlidXRlLmNvbmNhdChnZW5lcmF0ZURyYXdpbmdDYXJkcygyMCkpXHJcbiAgICAgIHN0YXRlLm9yZGVyT2Zmc2V0ID0gbXlJZHhcclxuICAgIH0sXHJcblxyXG4gICAgcmVhZHkoc3RhdGUpIHtcclxuICAgICAgc3RhdGUucGxheWVycyA9IHN0YXRlLnBsYXllcnMubWFwKChwbGF5ZXIsIGlkeCkgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAuLi5wbGF5ZXIsXHJcbiAgICAgICAgICBjYXJkczogc3RhdGUuZHJhd2luZ1N0YWNrLmZpbHRlcigoYykgPT4gYy5mb3JQbGF5ZXIgPT09IGlkeCksXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgc3RhdGUuZHJhd2luZ1N0YWNrID0gc3RhdGUuZHJhd2luZ1N0YWNrLmZpbHRlcihcclxuICAgICAgICAoYykgPT4gdHlwZW9mIGMuZm9yUGxheWVyID09PSAndW5kZWZpbmVkJ1xyXG4gICAgICApXHJcbiAgICB9LFxyXG5cclxuICAgIHN0b3BHYW1lKHN0YXRlKSB7XHJcbiAgICAgIHN0YXRlLmluR2FtZSA9IGZhbHNlXHJcbiAgICB9LFxyXG5cclxuICAgIHNldEluTG9iYnkoc3RhdGUsIGFjdGlvbjogUGF5bG9hZEFjdGlvbjxib29sZWFuPikge1xyXG4gICAgICBzdGF0ZS5pbkxvYmJ5ID0gYWN0aW9uLnBheWxvYWRcclxuICAgIH0sXHJcblxyXG4gICAgbW92ZUNhcmQoXHJcbiAgICAgIHN0YXRlLFxyXG4gICAgICBhY3Rpb246IFBheWxvYWRBY3Rpb248e1xyXG4gICAgICAgIGN1clBsYXllcjogbnVtYmVyXHJcbiAgICAgICAgbmV4dFBsYXllcjogbnVtYmVyXHJcbiAgICAgICAgY2FyZD86IENhcmRcclxuICAgICAgICBkcmF3PzogbnVtYmVyXHJcbiAgICAgICAgY2FyZHNUb0RyYXc/OiBDYXJkW11cclxuICAgICAgfT5cclxuICAgICkge1xyXG4gICAgICBsZXQgeyBjdXJQbGF5ZXIsIG5leHRQbGF5ZXIsIGNhcmQsIGNhcmRzVG9EcmF3ID0gW10sIGRyYXcgfSA9IGFjdGlvbi5wYXlsb2FkXHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGN1clBsYXllciBmcm9tIHNlcnZlciBpbmRleCB0byBVSSBpbmRleFxyXG4gICAgICBjdXJQbGF5ZXIgPSB3cmFwTW9kKFxyXG4gICAgICAgIGN1clBsYXllciAtIHN0YXRlLm9yZGVyT2Zmc2V0LFxyXG4gICAgICAgIHN0YXRlLnBsYXllcnMubGVuZ3RoXHJcbiAgICAgIClcclxuXHJcbiAgICAgIGNvbnN0IGN1clBsYXllck9iaiA9IHN0YXRlLnBsYXllcnNbY3VyUGxheWVyXVxyXG5cclxuICAgICAgbmV4dFBsYXllciA9IHdyYXBNb2QoXHJcbiAgICAgICAgbmV4dFBsYXllciAtIHN0YXRlLm9yZGVyT2Zmc2V0LFxyXG4gICAgICAgIHN0YXRlLnBsYXllcnMubGVuZ3RoXHJcbiAgICAgIClcclxuXHJcbiAgICAgIGlmIChjYXJkPy5hY3Rpb24gPT09ICdyZXZlcnNlJykgc3RhdGUuZGlyZWN0aW9uICo9IC0xXHJcblxyXG4gICAgICBpZiAoZHJhdykge1xyXG4gICAgICAgIHN0YXRlLnBsYXllcnMgPSBzdGF0ZS5wbGF5ZXJzLm1hcCgocCkgPT4ge1xyXG4gICAgICAgICAgaWYgKHAuaWQgPT09IGN1clBsYXllck9iai5pZCkge1xyXG4gICAgICAgICAgICBsZXQgbmV3Q2FyZHMgPSBzdGF0ZS5kcmF3aW5nU3RhY2suc2xpY2UoMCwgZHJhdylcclxuICAgICAgICAgICAgaWYgKGN1clBsYXllck9iai5pZCA9PT0gc3RhdGUucGxheWVySWQgJiYgY2FyZHNUb0RyYXcpIHtcclxuICAgICAgICAgICAgICBuZXdDYXJkcyA9IG5ld0NhcmRzLm1hcCgoYywgaWR4KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgLi4uYyxcclxuICAgICAgICAgICAgICAgIC4uLmNhcmRzVG9EcmF3W2lkeF0sXHJcbiAgICAgICAgICAgICAgICByb3RhdGlvblk6IDAsXHJcbiAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAuLi5wLFxyXG4gICAgICAgICAgICAgIGNhcmRzOiBwLmNhcmRzLmNvbmNhdChuZXdDYXJkcyksXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBwXHJcbiAgICAgICAgfSlcclxuICAgICAgICBzdGF0ZS5kcmF3aW5nU3RhY2sgPSBzdGF0ZS5kcmF3aW5nU3RhY2tcclxuICAgICAgICAgIC5zbGljZShkcmF3KVxyXG4gICAgICAgICAgLmNvbmNhdChnZW5lcmF0ZURyYXdpbmdDYXJkcyhkcmF3KSlcclxuICAgICAgICBzdGF0ZS5sYXN0UGxheWVyRHJhd2VkID0gdHJ1ZVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2FyZCkge1xyXG4gICAgICAgIGxldCBsYXlvdXRJZDogc3RyaW5nIHwgdW5kZWZpbmVkID0gJydcclxuICAgICAgICBsZXQgc2hvdWxkRmxpcCA9IGZhbHNlXHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHBsYXllciBhY3R1YWxseSBoYXMgdGhlIGNhcmQgKG9yIGFueSBjYXJkIGlmIG5vdCBsb2NhbCBwbGF5ZXIpXHJcbiAgICAgICAgY29uc3QgaGFzQ2FyZCA9IGN1clBsYXllck9iai5jYXJkcy5zb21lKGMgPT4gY3VyUGxheWVyT2JqLmlkID09PSBzdGF0ZS5wbGF5ZXJJZCA/IGMuaWQgPT09IGNhcmQ/LmlkIDogdHJ1ZSlcclxuXHJcbiAgICAgICAgaWYgKGhhc0NhcmQgJiYgY3VyUGxheWVyT2JqLmNhcmRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGlmIChjdXJQbGF5ZXJPYmouaWQgIT09IHN0YXRlLnBsYXllcklkKSB7XHJcbiAgICAgICAgICAgIGxheW91dElkID1cclxuICAgICAgICAgICAgICBjdXJQbGF5ZXJPYmouY2FyZHNbXHJcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJQbGF5ZXJPYmouY2FyZHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgIF0ubGF5b3V0SWRcclxuICAgICAgICAgICAgc2hvdWxkRmxpcCA9IHRydWVcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxheW91dElkID0gY3VyUGxheWVyT2JqLmNhcmRzLmZpbmQoKGMpID0+IGMuaWQgPT09IGNhcmQ/LmlkKT8ubGF5b3V0SWRcclxuICAgICAgICAgICAgY29uc3QgY2FyZFRvTW92ZSA9IGN1clBsYXllck9iai5jYXJkcy5maWx0ZXIoXHJcbiAgICAgICAgICAgICAgKGMpID0+IGMubGF5b3V0SWQgPT09IGxheW91dElkXHJcbiAgICAgICAgICAgIClbMF1cclxuXHJcbiAgICAgICAgICAgIGlmIChjYXJkVG9Nb3ZlKSB7XHJcbiAgICAgICAgICAgICAgY2FyZC5jb2xvciA9IGNhcmRUb01vdmUuY29sb3JcclxuICAgICAgICAgICAgICBjYXJkLmFjdGlvbiA9IGNhcmRUb01vdmUuYWN0aW9uXHJcbiAgICAgICAgICAgICAgY2FyZC5kaWdpdCA9IGNhcmRUb01vdmUuZGlnaXRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBDYXJkIG5vdCBpbiBoYW5kIChlLmcuIGZpcnN0IGNhcmQgcGxheWVkIGJ5IHN5c3RlbSlcclxuICAgICAgICAgIC8vIEFuaW1hdGUgZnJvbSBkcmF3aW5nIHN0YWNrIChkZWNrKVxyXG4gICAgICAgICAgbGF5b3V0SWQgPSBgc3lzdGVtX21vdmVfJHtjYXJkTGF5b3V0SWRJZHgrK31gXHJcbiAgICAgICAgICBzaG91bGRGbGlwID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUudGFibGVTdGFjayA9IFtcclxuICAgICAgICAgIC4uLnN0YXRlLnRhYmxlU3RhY2suc2xpY2UoLTEpLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBsYXlvdXRJZDogbGF5b3V0SWQgfHwgYHVua25vd25fJHtjYXJkTGF5b3V0SWRJZHgrK31gLFxyXG4gICAgICAgICAgICBjb2xvcjogY2FyZC5jb2xvcixcclxuICAgICAgICAgICAgYWN0aW9uOiBjYXJkLmFjdGlvbixcclxuICAgICAgICAgICAgZGlnaXQ6IGNhcmQuZGlnaXQsXHJcbiAgICAgICAgICAgIGZsaXA6IHNob3VsZEZsaXAsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uWTogMCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXVxyXG5cclxuICAgICAgICAvLyBPbmx5IHJlbW92ZSBjYXJkIGlmIGl0IHdhcyBpbiBoYW5kXHJcbiAgICAgICAgaWYgKGhhc0NhcmQpIHtcclxuICAgICAgICAgIHN0YXRlLnBsYXllcnMgPSBzdGF0ZS5wbGF5ZXJzLm1hcCgocCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocCA9PT0gY3VyUGxheWVyT2JqKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgICAgICBjYXJkczogcC5jYXJkcy5maWx0ZXIoKGMpID0+IGMubGF5b3V0SWQgIT09IGxheW91dElkKSxcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLmxhc3RQbGF5ZXJEcmF3ZWQgPSBmYWxzZVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzdGF0ZS5uZXh0UGxheXJlID0gbmV4dFBsYXllclxyXG4gICAgfSxcclxuICAgIG1vdmVQbGF5ZXIoc3RhdGUpIHtcclxuICAgICAgc3RhdGUucGxheWVycyA9IHN0YXRlLnBsYXllcnMubWFwKChwKSA9PiB7XHJcbiAgICAgICAgaWYgKHAuaWQgPT09IHN0YXRlLnBsYXllcklkKSB7XHJcbiAgICAgICAgICBjb25zdCBteVR1cm4gPSBzdGF0ZS5uZXh0UGxheXJlID09PSAwXHJcblxyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgY2FyZHM6IHAuY2FyZHMubWFwKChjKSA9PiB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC4uLmMsXHJcbiAgICAgICAgICAgICAgICBwbGF5YWJsZTpcclxuICAgICAgICAgICAgICAgICAgbXlUdXJuICYmXHJcbiAgICAgICAgICAgICAgICAgIGNhblBsYXlDYXJkKFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRhYmxlU3RhY2tbc3RhdGUudGFibGVTdGFjay5sZW5ndGggLSAxXSxcclxuICAgICAgICAgICAgICAgICAgICBjLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmxhc3RQbGF5ZXJEcmF3ZWRcclxuICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcFxyXG4gICAgICB9KVxyXG4gICAgICBzdGF0ZS5jdXJyZW50UGxheWVyID0gc3RhdGUubmV4dFBsYXlyZVxyXG4gICAgfSxcclxuICB9LFxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IHtcclxuICBpbml0LFxyXG4gIHJlYWR5LFxyXG4gIHN0b3BHYW1lLFxyXG4gIG1vdmVDYXJkLFxyXG4gIG1vdmVQbGF5ZXIsXHJcbiAgc2V0SW5Mb2JieSxcclxuICBzZXRQbGF5ZXJJZCxcclxufSA9IGdhbWVTbGljZS5hY3Rpb25zXHJcblxyXG5leHBvcnQgZGVmYXVsdCBnYW1lU2xpY2UucmVkdWNlclxyXG5cclxuIl0sIm5hbWVzIjpbImNyZWF0ZVNsaWNlIiwiY2FuUGxheUNhcmQiLCJ3cmFwTW9kIiwiY2FyZExheW91dElkSWR4IiwiZ2VuZXJhdGVEcmF3aW5nQ2FyZHMiLCJjbnQiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJsYXlvdXRJZCIsImluaXRpYWxTdGF0ZSIsInBsYXllcklkIiwiY3VycmVudFBsYXllciIsIm5leHRQbGF5cmUiLCJvcmRlck9mZnNldCIsImRpcmVjdGlvbiIsInRhYmxlU3RhY2siLCJkcmF3aW5nU3RhY2siLCJwbGF5ZXJzIiwibGFzdFBsYXllckRyYXdlZCIsImluR2FtZSIsImluTG9iYnkiLCJnYW1lU2xpY2UiLCJuYW1lIiwicmVkdWNlcnMiLCJzZXRQbGF5ZXJJZCIsInN0YXRlIiwiYWN0aW9uIiwicGF5bG9hZCIsImluaXQiLCJjYXJkcyIsInN0YXJ0aW5nQ2FyZHMiLCJmaXJzdENhcmQiLCJyb3RhdGlvblkiLCJwbGF5ZXJzRmluYWwiLCJteUlkeCIsImxlbmd0aCIsImlkIiwiaSIsInB1c2giLCJjYXJkc1RvRGlzdHJpYnV0ZSIsImMiLCJwbGF5YWJsZSIsImZvclBsYXllciIsImNvbmNhdCIsInJlYWR5IiwicGxheWVyIiwiaWR4IiwiZmlsdGVyIiwic3RvcEdhbWUiLCJzZXRJbkxvYmJ5IiwibW92ZUNhcmQiLCJjdXJQbGF5ZXIiLCJuZXh0UGxheWVyIiwiY2FyZCIsImNhcmRzVG9EcmF3IiwiZHJhdyIsImN1clBsYXllck9iaiIsInAiLCJuZXdDYXJkcyIsInNsaWNlIiwic2hvdWxkRmxpcCIsImhhc0NhcmQiLCJzb21lIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZmluZCIsImNhcmRUb01vdmUiLCJjb2xvciIsImRpZ2l0IiwiZmxpcCIsIm1vdmVQbGF5ZXIiLCJteVR1cm4iLCJhY3Rpb25zIiwicmVkdWNlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./stores/features/gameSlice.ts\n"));

/***/ })

});